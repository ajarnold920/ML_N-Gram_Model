@ Override  public   DescriptorImpl   getDescriptor ()   {  return  ( DescriptorImpl )   super . getDescriptor () ;  }
@ Override  public   void   setUp ( Context   context ,  Run < ? ,  ? >   build ,  FilePath   workspace ,  Launcher   launcher ,  TaskListener   listener ,  EnvVars   initialEnvironment )   throws  IOException ,  InterruptedException   {  final   ColorizedAction   action   =  new   ColorizedAction ( colorMapName ,  ColorizedAction . Command . START ) ;  build . replaceAction ( action ) ;  listener . annotate ( new   ActionNote ( action ) ) ;  }
private   AnsiColorMap []   withDefaults ( AnsiColorMap []   colorMaps )   {  Map < String ,  AnsiColorMap >   maps   =  new   LinkedHashMap <> () ;  addAll ( AnsiColorMap . defaultColorMaps () ,  maps ) ;  addAll ( colorMaps ,  maps ) ;  return  maps . values () . toArray ( new   AnsiColorMap [ 1 ] ) ;  }
private   void   addAll ( AnsiColorMap []   maps ,  Map < String ,  AnsiColorMap >   to )   {  for  ( AnsiColorMap   map   :  maps )   {  to . put ( map . getName () ,  map ) ;  }  }
private   void   validateFieldName ( String   fieldValue )   throws  FormException   {  final   FormValidation   validation   =  doCheckName ( fieldValue ) ;  if  ( validation . kind   !=   FormValidation . Kind . OK )   {  throw  new   FormException ( validation . getMessage () ,  ""name"" ) ;  }  }
private   void   validateFieldColorLiteral ( String   fieldName ,  String   fieldValue )   throws  FormException   {  final   FormValidation   globalColorMapNameValidation   =  validateColorLiteral ( fieldValue ) ;  if  ( globalColorMapNameValidation . kind   !=   FormValidation . Kind . OK )   {  throw  new   FormException ( globalColorMapNameValidation . getMessage () ,  fieldName ) ;  }  }
private   void   validateFields ( AnsiColorMap   ansiColorMap )   throws  FormException   {  for  ( Map . Entry < String ,  Function < AnsiColorMap ,  String > >   e   :  VALIDATED_FIELDS . entrySet () )   {  validateFieldColorLiteral ( e . getKey () ,  e . getValue () . apply ( ansiColorMap ) ) ;  }  }
public   FormValidation   doCheckGlobalColorMapName ( @ QueryParameter   String   value )   {  return  value . isEmpty ()  ?   FormValidation . ok ()   :  validateColorMapName ( value ) ;  }
@ SuppressWarnings ( ""unused"" )  public   FormValidation   doCheckName ( @ QueryParameter   final   String   value )   {  return  validateColorMapName ( value ) ;  }
private   FormValidation   validateColorMapName ( String   name )   {  final   int   nameLength   =  name . trim () . length () ;  return  ( nameLength   <   1   ||   nameLength   >   256 )  ?   FormValidation . error ( ""Color map name length must be between 1 and 256 chars."" )   :  FormValidation . ok () ;  }
public   FormValidation   doCheckBlack ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckBlackB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckRed ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckRedB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckGreen ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckGreenB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckYellow ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckYellowB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckBlue ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckBlueB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckMagenta ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckMagentaB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckCyan ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckCyanB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckWhite ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
public   FormValidation   doCheckWhiteB ( @ QueryParameter   String   value )   {  return  validateColorLiteral ( value ) ;  }
private   FormValidation   validateColorLiteral ( String   name )   {  final   int   nameLength   =  name . trim () . length () ;  return  ( nameLength   <   1   ||   nameLength   >   64 )  ?   FormValidation . error ( ""Color literal length must be between 1 and 64 chars."" )   :  FormValidation . ok () ;  }
public   String   getGlobalColorMapName ()   {  return  globalColorMapName ;  }
public   void   setGlobalColorMapName ( String   colorMapName )   {  globalColorMapName   =   colorMapName ;  }
public   AnsiColorMap []   getColorMaps ()   {  return  withDefaults ( colorMaps ) ;  }
public   void   setColorMaps ( AnsiColorMap []   maps )   {  colorMaps   =   maps . clone () ;  }
public   AnsiColorMap   getColorMap ( final   String   name )   {  for  ( AnsiColorMap   colorMap   :  getColorMaps () )   {  if  ( colorMap . getName () . equals ( name ) )   {  return  colorMap ;  }  }  return  AnsiColorMap . Default ;  }
@ SuppressWarnings ( ""unused"" )  public   ListBoxModel   doFillColorMapNameItems ()   {  ListBoxModel   m   =  new   ListBoxModel () ;  for  ( AnsiColorMap   colorMap   :  getColorMaps () )   {  String   name   =  colorMap . getName () . trim () ;  if  ( name . length ()   >   0 )   {  m . add ( name ) ;  }  }  return  m ;  }
@ SuppressWarnings ( ""unused"" )  public   ListBoxModel   doFillDefaultForegroundItems ()   {  ListBoxModel   m   =  new   ListBoxModel () ;  m . add ( ""Jenkins Default"" ,  """" ) ;  for  ( AnsiColorMap . Color   color   :  AnsiColorMap . Color . values () )   {  m . add ( color . toString () ,  String . valueOf ( color . ordinal () ) ) ;  }  return  m ;  }
@ SuppressWarnings ( ""unused"" )  public   ListBoxModel   doFillDefaultBackgroundItems ()   {  return  doFillDefaultForegroundItems () ;  }
@ Override  public   String   getDisplayName ()   {  return  Messages . DisplayName () ;  }
@ Override  public   boolean   isApplicable ( AbstractProject < ? ,  ? >   item )   {  return  true ;  }
@ Override  public   String   toString ()   {  
public   static   AnsiColorMap []   defaultColorMaps ()   {  return  ( AnsiColorMap [] )   DefaultColorMaps . clone () ;  }
@ Override  public   int   hashCode ()   {  return  new   HashCodeBuilder ( 41 ,  89 ) .  append ( name ) .  append ( normalMap ) .  append ( brightMap ) .  append ( defaultForeground ) .  append ( defaultBackground ) .  toHashCode () ;  }
@ Override  public   boolean   equals ( Object   obj )   {  if  ( ! ( obj   instanceof   AnsiColorMap ) )   {  return  false ;  }  if  ( obj   ==   this )   {  return  true ;  }  AnsiColorMap   ansiColorMap   =  ( AnsiColorMap )   obj ;  return  new   EqualsBuilder () .  append ( name ,  ansiColorMap . name ) .  append ( normalMap ,  ansiColorMap . normalMap ) .  append ( brightMap ,  ansiColorMap . brightMap ) .  append ( defaultForeground ,  ansiColorMap . defaultForeground ) .  append ( defaultBackground ,  ansiColorMap . defaultBackground ) .  isEquals () ;  }
public   String   getBlack ()   {  return  normalMap . get ( Color . BLACK ) ;  }
public   String   getGreen ()   {  return  normalMap . get ( Color . GREEN ) ;  }
public   String   getYellow ()   {  return  normalMap . get ( Color . YELLOW ) ;  }
public   String   getBlue ()   {  return  normalMap . get ( Color . BLUE ) ;  }
public   String   getMagenta ()   {  return  normalMap . get ( Color . MAGENTA ) ;  }
public   String   getCyan ()   {  return  normalMap . get ( Color . CYAN ) ;  }
public   String   getWhite ()   {  return  normalMap . get ( Color . WHITE ) ;  }
public   String   getBlackB ()   {  return  brightMap . get ( Color . BLACK ) ;  }
public   String   getRedB ()   {  return  brightMap . get ( Color . RED ) ;  }
public   String   getGreenB ()   {  return  brightMap . get ( Color . GREEN ) ;  }
public   String   getYellowB ()   {  return  brightMap . get ( Color . YELLOW ) ;  }
public   String   getBlueB ()   {  return  brightMap . get ( Color . BLUE ) ;  }
public   String   getMagentaB ()   {  return  brightMap . get ( Color . MAGENTA ) ;  }
public   String   getCyanB ()   {  return  brightMap . get ( Color . CYAN ) ;  }
public   String   getWhiteB ()   {  return  brightMap . get ( Color . WHITE ) ;  }
public   String   getNormal ( int   index )   {  return  normalMap . get ( Color . values () [ index ] ) ;  }
public   String   getBright ( int   index )   {  return  brightMap . get ( Color . values () [ index ] ) ;  }
public   Integer   getDefaultForeground ()   {  return  defaultForeground ;  }
public   Integer   getDefaultBackground ()   {  return  defaultBackground ;  }
@ Override  public   ConsoleAnnotator   annotate ( Object   context ,  MarkupText   text ,  int   charPos )   {  text . addMarkup ( charPos ,  tagHtml ) ;  return  null ;  }
private   static   DescriptorImpl   getWrapperDescriptor ()   {  return  Jenkins . get () . getDescriptorByType ( DescriptorImpl . class ) ;  }
@ Override  public   StepExecution   start ( StepContext   context )   throws  Exception   {  return  new   ExecutionImpl ( context ,  colorMapName ) ;  }
@ Override  public   boolean   start ()   throws  Exception   {  StepContext   context   =  getContext () ;  EnvironmentExpander   currentEnvironment   =  context . get ( EnvironmentExpander . class ) ;  EnvironmentExpander   terminalEnvironment   =  EnvironmentExpander . constant ( Collections . singletonMap ( ""TERM"" ,  colorMapName ) ) ;  context . newBodyInvoker ()  . withContext ( EnvironmentExpander . merge ( currentEnvironment ,  terminalEnvironment ) )  . withCallback ( new   AnsiColorExecution ( colorMapName ) )  . start () ;  return  false ;  }
@ NonNull  @ Override  public   String   getDisplayName ()   {  return  Messages . DisplayName () ;  }
@ Override  public   String   getFunctionName ()   {  return  ""ansiColor"" ;  }
@ Override  public   boolean   takesImplicitBlockArgument ()   {  return  true ;  }
public   ListBoxModel   doFillColorMapNameItems ()   {  return  getWrapperDescriptor () . doFillColorMapNameItems () ;  }
@ Override  public   Set < ?   extends  Class < ? > >   getRequiredContext ()   {  return  Collections . singleton ( Run . class ) ;  }
@ Override  public   void   onStart ( StepContext   context )   {  issueAction ( context ,  new   ColorizedAction ( colorMapName ,  ColorizedAction . Command . START ) ) ;  super . onStart ( context ) ;  }
@ Override  public   void   onSuccess ( StepContext   context ,  Object   result )   {  issueAction ( context ,  new   ColorizedAction ( colorMapName ,  ColorizedAction . Command . STOP ) ) ;  context . onSuccess ( result ) ;  }
@ Override  public   void   onFailure ( StepContext   context ,  Throwable   t )   {  issueAction ( context ,  new   ColorizedAction ( colorMapName ,  ColorizedAction . Command . STOP ) ) ;  context . onFailure ( t ) ;  }
private   void   issueAction ( StepContext   context ,  ColorizedAction   action )   {  try  {  final   TaskListener   taskListener   =  context . get ( TaskListener . class ) ;  final   Run < ? ,  ? >   run   =  context . get ( Run . class ) ;  if  ( taskListener   !=   null   &&   run   !=   null )   {  run . addAction ( action ) ;  taskListener . annotate ( new   ActionNote ( action ) ) ;  ensureRendering ( taskListener ) ;  final   ColorizedAction   currentAction   =  new   ColorizedAction ( action . getColorMapName () ,  ColorizedAction . Command . CURRENT ) ;  if  ( action . getCommand () . equals ( ColorizedAction . Command . START ) )   {  run . addAction ( currentAction ) ;  }   else  {  run . removeAction ( currentAction ) ;  }  }  }   catch  ( IOException  |  InterruptedException   e )   {  LOGGER . log ( Level . WARNING ,  ""Could not annotate. Ansicolor plugin will not work correctly."" ,  e ) ;  }  }
private   boolean   needsPrintln ()   {  if  ( needsPrintln   ==   null )   {  needsPrintln   =   EXTENSIONS_NL . entrySet () . stream () . anyMatch ( e  ->  ExtensionList . lookup ( e . getKey () ) . stream () . map ( ext  ->   ext . getClass () . getName () ) . anyMatch ( n  ->   Arrays . stream ( e . getValue () ) . anyMatch ( n :: contains ) ) ) ;  }  return  needsPrintln ;  }
private   void   ensureRendering ( TaskListener   taskListener )   {  if  ( needsPrintln () )   {  taskListener . getLogger () . println () ;  }  }
private   void   pregenerateNote ( AnsiAttributeElement   element )   {  element . emitOpen ( html  ->   pregenerateNote ( html ) ) ;  element . emitClose ( html  ->   pregenerateNote ( html ) ) ;  }
private   void   pregenerateNote ( String   html )   {  if  ( ! notes . containsKey ( html ) )   {  JenkinsJVM . checkJenkinsJVM () ;  ByteArrayOutputStream   baos   =  new   ByteArrayOutputStream () ;  try  {  new   SimpleHtmlNote ( html ) . encodeTo ( baos ) ;  }   catch  ( IOException   x )   {   
private   Object   readResolve ()   {   
@ Override  public   void   emitHtml ( @ NonNull   String   html )   {  try  {  byte []   pregenerated   =  notes . get ( html ) ;  if  ( pregenerated   !=   null )   {  logger . write ( pregenerated ) ;  }   else  {  
public   void   emitOpen ( Emitter   emitter )   {  final   String   openingTagHtml   =  ""<""   +   name   +   ( attributes . trim () . equals ( """" )  ?   """"   :  "" ""   +   attributes )   +   "">"" ;  emitter . emitHtml ( openingTagHtml ) ;  }
public   void   emitClose ( Emitter   emitter )   {  String   closingTagHtml   =  ""</""   +   name   +   "">"" ;  emitter . emitHtml ( closingTagHtml ) ;  }
@ Override  public   boolean   equals ( Object   o )   {  if  ( this   ==   o )   {  return  true ;  }  if  ( o   ==   null   ||   getClass ()   !=   o . getClass () )   {  return  false ;  }  AnsiAttributeElement   tag   =  ( AnsiAttributeElement )   o ;  return  attributes . equals ( tag . attributes )   &&   name . equals ( tag . name )   &&   ansiAttrType   ==   tag . ansiAttrType ;  }
@ Override  public   int   hashCode ()   {  int   result   =  ansiAttrType . hashCode () ;  result   =   31   *   result   +   name . hashCode () ;  result   =   31   *   result   +   attributes . hashCode () ;  return  result ;  }
@ Override  public   String   toString ()   {  return  ""AnsiAttributeElement{ansiAttrType=""   +   ansiAttrType   +   "",name=""   +   name   +   "",attributes=""   +   attributes   +   ""}"" ;  }
public   static   AnsiAttributeElement   bold ()   {  return  new   AnsiAttributeElement ( AnsiAttributeElement . AnsiAttrType . BOLD ,  ""b"" ,  """" ) ;  }
public   static   AnsiAttributeElement   faint ()   {  return  new   AnsiAttributeElement ( AnsiAttributeElement . AnsiAttrType . FAINT ,  ""span"" ,  ""style=\""font-weight: lighter;\"""" ) ;  }
public   static   AnsiAttributeElement   italic ()   {  return  new   AnsiAttributeElement ( AnsiAttrType . ITALIC ,  ""i"" ,  """" ) ;  }
public   static   AnsiAttributeElement   underline ()   {  return  new   AnsiAttributeElement ( AnsiAttrType . UNDERLINE ,  ""u"" ,  """" ) ;  }
public   static   AnsiAttributeElement   underlineDouble ()   {  return  new   AnsiAttributeElement ( AnsiAttrType . UNDERLINE ,  ""span"" ,  ""style=\""border-bottom: 3px double;\"""" ) ;  }
public   static   AnsiAttributeElement   strikeout ()   {  return  new   AnsiAttributeElement ( AnsiAttrType . STRIKEOUT ,  ""span"" ,  ""style=\""text-decoration: line-through;\"""" ) ;  }
public   static   AnsiAttributeElement   framed ()   {  return  new   AnsiAttributeElement ( AnsiAttrType . FRAMED ,  ""span"" ,  ""style=\""border: 1px solid;\"""" ) ;  }
public   static   AnsiAttributeElement   overline ()   {  return  new   AnsiAttributeElement ( AnsiAttrType . OVERLINE ,  ""span"" ,  ""style=\""text-decoration: overline;\"""" ) ;  }
 <argument pos:start=""""169:98"""" pos:end=""""169:104""""><expr pos:start=""""169:98"""" pos:end=""""169:104""""><literal type=""""string"""" pos:start=""""169:98"""" pos:end=""""169:104"""">""""UTF-8""""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 <argument pos:start=""""185:95"""" pos:end=""""185:101""""><expr pos:start=""""185:95"""" pos:end=""""185:101""""><literal type=""""string"""" pos:start=""""185:95"""" pos:end=""""185:101"""">""""UTF-8""""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 <argument pos:start=""""198:95"""" pos:end=""""198:101""""><expr pos:start=""""198:95"""" pos:end=""""198:101""""><literal type=""""string"""" pos:start=""""198:95"""" pos:end=""""198:101"""">""""UTF-8""""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
private   void   reset ( boolean   skipBuffer )   throws  IOException   {  if  ( ! skipBuffer )   {  out . write ( buffer ,  0 ,  pos ) ;  }  pos   =   0 ;  startOfValue   =   0 ;  options . clear () ;  state   =   LOOKING_FOR_FIRST_ESC_CHAR ;  }
private   int   getNextOptionInt ( Iterator < Object >   optionsIterator )   throws  IOException   {  for  ( ; ; )   {  if  ( ! optionsIterator . hasNext () )  throw  new   IllegalArgumentException () ;  Object   arg   =  optionsIterator . next () ;  if  ( arg   !=   null )  return  ( ( Integer ) arg ) . intValue () ;  }  }
private   boolean   processOperatingSystemCommand ( ArrayList < Object >   options )   throws  IOException   {  int   command   =  optionInt ( options ,  0 ) ;  String   label   =  ( String )   options . get ( 1 ) ;  
protected   void   processRestoreCursorPosition ()   throws  IOException   {  }
protected   void   processScrollDown ( int   optionInt )   throws  IOException   {  }
protected   void   processScrollUp ( int   optionInt )   throws  IOException   {  }
protected   void   processEraseScreen ( int   eraseOption )   throws  IOException   {  }
protected   void   processEraseLine ( int   eraseOption )   throws  IOException   {  }
protected   void   processSetAttribute ( int   attribute )   throws  IOException   {  }
protected   void   processSetForegroundColor ( int   color )   throws  IOException   {  processSetForegroundColor ( color ,  false ) ;  }
protected   void   processSetForegroundColor ( int   color ,  boolean   bright )   throws  IOException   {  }
protected   void   processSetForegroundColorExt ( int   paletteIndex )   throws  IOException   {  }
protected   void   processSetForegroundColorExt ( int   r ,  int   g ,  int   b )   throws  IOException   {  }
protected   void   processSetBackgroundColor ( int   color )   throws  IOException   {  processSetBackgroundColor ( color ,  false ) ;  }
protected   void   processSetBackgroundColor ( int   color ,  boolean   bright )   throws  IOException   {  }
protected   void   processSetBackgroundColorExt ( int   paletteIndex )   throws  IOException   {  }
protected   void   processSetBackgroundColorExt ( int   r ,  int   g ,  int   b )   throws  IOException   {  }
protected   void   processDefaultBackgroundColor ()   throws  IOException   {  }
protected   void   processCursorTo ( int   row ,  int   col )   throws  IOException   {  }
protected   void   processCursorToColumn ( int   x )   throws  IOException   {  }
protected   void   processCursorUpLine ( int   count )   throws  IOException   {  }
protected   void   processCursorDownLine ( int   count )   throws  IOException   {  
protected   void   processCursorLeft ( int   count )   throws  IOException   {  }
protected   void   processCursorRight ( int   count )   throws  IOException   {  
protected   void   processCursorDown ( int   count )   throws  IOException   {  }
protected   void   processCursorUp ( int   count )   throws  IOException   {  }
protected   void   processUnknownExtension ( ArrayList < Object >   options ,  int   command )   {  }
protected   void   processChangeIconNameAndWindowTitle ( String   label )   {  processChangeIconName ( label ) ;  processChangeWindowTitle ( label ) ;  }
protected   void   processUnknownOperatingSystemCommand ( int   command ,  String   param )   {  }
private   boolean   processCharsetSelect ( ArrayList < Object >   options )   throws  IOException   {  int   set   =  optionInt ( options ,  0 ) ;  char   seq   =  ( ( Character )   options . get ( 1 ) ) . charValue () ;  processCharsetSelect ( set ,  seq ) ;  return  true ;  }
private   int   optionInt ( ArrayList < Object >   options ,  int   index )   {  if  ( options . size ()   <=   index )  throw  new   IllegalArgumentException () ;  Object   value   =  options . get ( index ) ;  if  ( value   ==   null )  throw  new   IllegalArgumentException () ;  if  ( ! value . getClass () . equals ( Integer . class ) )  throw  new   IllegalArgumentException () ;  return  ( ( Integer )   value ) . intValue () ;  }
private   int   optionInt ( ArrayList < Object >   options ,  int   index ,  int   defaultValue )   {  if  ( options . size ()   >   index )   {  Object   value   =  options . get ( index ) ;  if  ( value   ==   null )   {  return  defaultValue ;  }  return  ( ( Integer )   value ) . intValue () ;  }  return  defaultValue ;  }
@ Override  public   void   close ()   throws  IOException   {  write ( REST_CODE ) ;  flush () ;  super . close () ;  }
@ Override  public   void   emitHtml ( @ NonNull   String   html )   {  final   int   inCount   =  getIncomingCount () ;  LOGGER . log ( Level . FINEST ,  ""emitting {0} @{1}/{2}"" ,  new   Object [] { html ,  inCount ,  s . length () } ) ;  text . addMarkup ( inCount ,  html ) ;  hideIfNeeded ( inCount ,  """" ) ;  }
private   int   getIncomingCount ()   {  final   int   inCount   =  incoming . getCount () ;  return  inCount   ==   1  ?   0   :  inCount ;  }
private   void   hideIfNeeded ( int   inCount ,  String   msg )   {  if  ( inCount   !=   lastPoint )   {  lastPoint   =   inCount ;  final   int   outCount   =  outgoing . getCount ()   +   adjustment ;  final   int   hide   =  inCount   -   outCount ;  
@ Override  public   void   emitInvisibleSequence ()   {  hideIfNeeded ( getIncomingCount () ,  "" (ANSI sequence with no corresponding HTML tags)"" ) ;  }
@ CheckForNull  private   static   Run < ? ,  ? >   runOf ( Object   context )   {  LOGGER . log ( Level . FINE ,  ""context={0}"" ,  context ) ;  if  ( context   instanceof   Run )   {  return  ( Run < ? ,  ? > )   context ;  }   else if  ( Jenkins . get () . getPlugin ( ""workflow-api"" )   !=   null   &&   context   instanceof   FlowNode )   {  FlowNode   node   =  ( FlowNode )   context ;  FlowExecutionOwner   owner   =  node . getExecution () . getOwner () ;  if  ( owner   !=   null )   {  Queue . Executable   exec   =  null ;  try  {  exec   =   owner . getExecutable () ;  }   catch  ( IOException   x )   {  LOGGER . log ( Level . WARNING ,  null ,  x ) ;  }  if  ( exec   instanceof   Run )   {  return  ( Run < ? ,  ? > )   exec ;  }  }  }  return  null ;  }
@ Override  public   ConsoleAnnotator < Object >   newInstance ( Object   context )   {  return  newInstance ( context ,  0 ) ;  }
private   ConsoleAnnotator < Object >   newInstance ( Object   context ,  long   startLineNo )   {  return  new   ColorConsoleAnnotator ( Jenkins . get () . getDescriptorByType ( AnsiColorBuildWrapper . DescriptorImpl . class ) . getGlobalColorMapName () ,  new   LineIdentifier () ,  startLineNo ) ;  }
@ SuppressWarnings ( ""unused"" )  private   void   logdebug ( String   format ,  Object ...   args )   throws  IOException   {  String   msg   =  String . format ( format ,  args ) ;  emitter . emitHtml ( ""<span style=\""border: 1px solid; color: #009000; background-color: #003000; font-size: 70%; font-weight: normal; font-style: normal\"">"" ) ;  out . write ( msg . getBytes ( StandardCharsets . UTF_8 ) ) ;  emitter . emitHtml ( ""</span>"" ) ;  }
private   void   startConcealing ()   {  this . out   =   new   NullStream () ;  }
private   void   openTag ( AnsiAttributeElement   tag )   {  openTags . add ( tag ) ;  tag . emitOpen ( emitter ) ;  }
private   void   closeOpenTags ( AnsiAttrType   until )   {  
private   void   collectAmbleCharacter ( int   data ,  byte []   amble )   throws  IOException   {  
@ Override  public   void   close ()   throws  IOException   {  stopConcealing () ;  closeOpenTags ( null ) ;  super . close () ;  }
public   void   setBackgroundColor ( String   color )   {  AnsiAttrType   attrType   =  ! swapColors  ?   AnsiAttrType . BG   :  AnsiAttrType . FG ;  String   attrName   =  ! swapColors  ?   ""background-color""   :  ""color"" ;  if  ( color   ==   null   &&   swapColors )   color   =   getDefaultBackgroundColor () ;  closeTagOfType ( attrType ) ;  if  ( color   !=   null )  openTag ( new   AnsiAttributeElement ( attrType ,  ""span"" ,  ""style=\""""   +   attrName   +   "": ""   +   color   +   "";\"""" ) ) ;  currentBackgroundColor   =   color ;  }
private   String   getRgbColor ( int   r ,  int   g ,  int   b )   {  if  ( r   <   0   ||   r   >   255   ||   g   <   0   ||   g   >   255   ||   b   <   0   ||   b   >   255 )  throw  new   IllegalArgumentException () ;  return  ""#""   +   String . format ( ""%02X"" ,  r )   +   String . format ( ""%02X"" ,  g )   +   String . format ( ""%02X"" ,  b ) ;  }
@ Override  protected   void   processAttributeRest ()   {  currentForegroundColor   =   null ;  currentBackgroundColor   =   null ;  swapColors   =   false ;  stopConcealing () ;  closeOpenTags ( AnsiAttrType . DEFAULT ) ;  }
@ Override  protected   void   processSetForegroundColor ( int   color )   {  setForegroundColor ( colorMap . getNormal ( color ) ) ;  }
@ Override  protected   void   processSetForegroundColor ( int   color ,  boolean   bright )   {  setForegroundColor ( colorMap . getBright ( color ) ) ;  }
@ Override  protected   void   processSetForegroundColorExt ( int   paletteIndex )   {  setForegroundColor ( getPaletteColor ( paletteIndex ) ) ;  }
@ Override  protected   void   processSetForegroundColorExt ( int   r ,  int   g ,  int   b )   {  setForegroundColor ( getRgbColor ( r ,  g ,  b ) ) ;  }
@ Override  protected   void   processSetBackgroundColor ( int   color )   {  setBackgroundColor ( colorMap . getNormal ( color ) ) ;  }
@ Override  protected   void   processSetBackgroundColor ( int   color ,  boolean   bright )   {  setBackgroundColor ( colorMap . getBright ( color ) ) ;  }
@ Override  protected   void   processSetBackgroundColorExt ( int   paletteIndex )   {  setBackgroundColor ( getPaletteColor ( paletteIndex ) ) ;  }
@ Override  protected   void   processSetBackgroundColorExt ( int   r ,  int   g ,  int   b )   {  setBackgroundColor ( getRgbColor ( r ,  g ,  b ) ) ;  }
@ Override  protected   void   processDefaultTextColor ()   {  setForegroundColor ( null ) ;  }
@ Override  protected   void   processDefaultBackgroundColor ()   {  setBackgroundColor ( null ) ;  }
@ Override  protected   void   processEraseLine ( int   eraseOption )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorDown ( int   count )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorUp ( int   count )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorLeft ( int   count )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorUpLine ( int   count )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processRestoreCursorPosition ()   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processSaveCursorPosition ()   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processScrollDown ( int   optionInt )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processScrollUp ( int   optionInt )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processEraseScreen ( int   eraseOption )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorTo ( int   row ,  int   col )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorToColumn ( int   x )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorDownLine ( int   count )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCursorRight ( int   count )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processUnknownExtension ( ArrayList < Object >   options ,  int   command )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processChangeIconName ( String   label )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processChangeWindowTitle ( String   label )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processUnknownOperatingSystemCommand ( int   command ,  String   param )   {  emitter . emitInvisibleSequence () ;  }
@ Override  protected   void   processCharsetSelect ( int   set ,  char   seq )   {  emitter . emitInvisibleSequence () ;  }
@ Override  public   ConsoleAnnotator < Run < ? ,  ? > >   annotate ( Run < ? ,  ? >   context ,  MarkupText   text ,  int   charPos )   {  text . addMarkup ( charPos ,  TAG_ACTION_BEGIN   +   String . format ( TAG_ACTION_ID_TEMPLATE ,  actionId )   +   TAG_ACTION_END ) ;  return  null ;  }
public   ColorizedAction   createActionForShortlog ( File   logFile ,  Map < String ,  ColorizedAction >   actions ,  int   shortlogLimit ,  boolean   keepLinesWhole ,  long   reservedBytes )   {  final   ActionContext   lastAction   =  findLastActionBefore ( logFile ,  actions . keySet () ,  shortlogLimit ,  keepLinesWhole ,  reservedBytes ) ;  if  ( ! lastAction . isEmpty () )   {  final   ColorizedAction   colorizedAction   =  actions . get ( lastAction . serializedAction ) ;  if  ( ColorizedAction . Command . START . equals ( colorizedAction . getCommand () ) )   {  return  new   ColorizedAction ( lineIdentifier . hash ( ConsoleNote . removeNotes ( lastAction . line ) ,  1 ) ,  colorizedAction ) ;  }  }  return  null ;  }
private   String   findLastAction ( Collection < String >   serializedActions ,  byte []   buf ,  int   maxPos )   {  String   lastAction   =  """" ;  int   preamblePos   =  0 ;  while  ( preamblePos   <   maxPos   &&   ( preamblePos   =   ConsoleNote . findPreamble ( buf ,  preamblePos ,  buf . length   -   preamblePos ) )   !=   - 1 )   {  final   int   begin   =  preamblePos ;  lastAction   =   serializedActions . stream () . filter ( sa  ->   buf . length   -   begin   >   sa . length ()   &&   sa . equals ( new   String ( buf ,  begin ,  sa . length () ,  UTF_8 ) ) ) . findFirst () . orElse ( lastAction ) ;  preamblePos ++ ;  }  return  lastAction ;  }
private   int   indexOfEol ( byte []   buf ,  int   after )   {  for  ( int   i   =  after   +   1 ;   i   <   buf . length ;   i ++ )   {  if  ( Arrays . equals ( Arrays . copyOfRange ( buf ,  i ,  i   +   eol . length ) ,  eol ) )   {  return  i ;  }  }  return  - 1 ;  }
private   int []   calculateBeginLength ( byte []   buf ,  int   startInBuff ,  int   eolPos ,  boolean   keepLinesWhole )   {  if  ( keepLinesWhole )   {  final   int   begin   =  eolPos   !=   - 1  ?   eolPos   +   eol . length   :  startInBuff ;  return  new   int [] { begin ,  eolPos   !=   - 1  ?   indexOfEol ( buf ,  eolPos )   -   begin   +   eol . length   :  - 1 } ;  }  return  new   int [] { startInBuff ,  eolPos   !=   - 1  ?   eolPos   -   startInBuff   +   eol . length   :  - 1 } ;  }
@ Override  public   void   onCompleted ( Run < ? ,  ? >   run ,  @ NonNull   TaskListener   listener )   {  super . onCompleted ( run ,  listener ) ;  final   List < ColorizedAction . Command >   commands   =  Arrays . asList ( ColorizedAction . Command . START ,  ColorizedAction . Command . STOP ) ;  final   Map < String ,  ColorizedAction >   actions   =  run . getActions ( ColorizedAction . class ) . stream ()  . filter ( a  ->   commands . contains ( a . getCommand () ) )  . collect ( Collectors . toMap ( a  ->  { try  {  return  new   ActionNote ( a ) . encode () ;  }   catch  ( IOException   e )   {  LOGGER . warning ( ""Will not be able to identify all ColorizedActions: ""   +   e . getMessage () ) ;  }  return  """" ;  }
public   boolean   isEmpty ()   {  return  serializedAction   ==   null   &&   line   ==   null ;  }
public   static   ColorizedAction   parseAction ( String   lineContent ,  long   lineNo ,  Run < ? ,  ? >   run ,  LineIdentifier   lineIdentifier )   {  return  run . getActions ( ColorizedAction . class ) . stream () . filter ( a  ->   lineIdentifier . isEqual ( lineContent ,  lineNo ,  a . id ) ) . findAny () . orElse ( CONTINUE ) ;  }
private   MessageDigest   getMessageDigest ()   {  if  ( messageDigest   ==   null )   {  try  {  messageDigest   =   MessageDigest . getInstance ( ALGORITHM ) ;  }   catch  ( NoSuchAlgorithmException   e )   {  throw  new   IllegalStateException ( ""Cannot get message digest"" ,  e ) ;  }  }  return  messageDigest ;  }
public   String   hash ( String   lineContent ,  long   lineNo )   {  final   String   key   =  String . join ( ""|"" ,  lineContent ,  String . valueOf ( lineNo ) ) ;  return  Base64 . getEncoder () . encodeToString ( getMessageDigest () . digest ( key . getBytes ( UTF_8 ) ) ) ;  }
public   boolean   isEqual ( String   lineContent ,  long   lineNo ,  String   other )   {  return  hash ( lineContent ,  lineNo ) . equals ( other ) ;  }
@ Test  void   testEmpty ()   throws  IOException   {  assertThatAnnotateIs ( """" ,  """" ) ;  }
@ Test  void   testNoMarkup ()   throws  IOException   {  assertThatAnnotateIs ( ""line"" ,  ""line"" ) ;  }
@ Test  void   testClearBlank ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[0m"" ,  """" ) ;  }
@ Test  void   testClear ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[0m\033[K"" ,  """" ) ;  }
@ Test  void   testConceal ()   throws  IOException   {  assertThatAnnotateIs ( ""there is concealed text here, \033[8mCONCEAL\033[0m, and it should vanish."" , ""there is concealed text here, , and it should vanish."" ) ;  }
@ Test  void   testEmbeddedConsoleNote ()   throws  IOException   {  assertThatAnnotateIs ( ""there is a ConsoleNote here, \033[8mha:CONSOLENOTE\033[0m, and it should be left untouched."" , ""there is a ConsoleNote here, \033[8mha:CONSOLENOTE\033[0m, and it should be left untouched."" ) ;  }
@ Test  void   testConcealedConsoleNote ()   throws  IOException   {  assertThatAnnotateIs ( ""there is a concealed note here, \033[8m\033[8mha:CONCEALEDCONSOLENOTE\033[0m\033[0m, ""   +  ""and it should vanish."" , ""there is a concealed note here, , and it should vanish."" ) ;  }
@ Test  void   testConcealedConsoleNoteDoesNotUnconceal ()   throws  IOException   {  assertThatAnnotateIs ( ""there is a concealed note here, \033[8m\033[8mha:CONCEALEDCONSOLENOTE\033[0m, ""   +  ""and it may not affect ongoing concealing."" , ""there is a concealed note here, "" ) ;  }
@ Test  void   testBold ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[1mhello world"" ,  ""<b>hello world</b>"" ) ;  }
@ Test  void   testUnderline ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[4mhello world"" ,  ""<u>hello world</u>"" ) ;  }
@ Test  void   testUnderlineDouble ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[21mhello world"" ,  ""<span style=\""border-bottom: 3px double;\"">hello world</span>"" ) ;  }
@ Test  void   testItalic ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[3mhello world\033[23mnormal"" ,  ""<i>hello world</i>normal"" ) ;  }
@ Test  void   testStrikeout ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[9mhello world\033[29mnormal"" ,  ""<span style=\""text-decoration: line-through;\"">hello world</span>normal"" ) ;  }
@ Test  void   testFramed ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[51mhello world\033[54mnormal"" ,  ""<span style=\""border: 1px solid;\"">hello world</span>normal"" ) ;  }
@ Test  void   testOverlined ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[53mhello world\033[55mnormal"" ,  ""<span style=\""text-decoration: overline;\"">hello world</span>normal"" ) ;  }
@ Test  void   testGreen ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[32mhello world"" ,  ""<span style=\""color: #00CD00;\"">hello world</span>"" ) ;  }
@ Test  void   testGreenXTerm ()   throws  IOException   {  assertThat ( annotate ( ""\033[32mhello world"" ,  AnsiColorMap . XTerm ) , is ( ""<span style=\""color: ""  +   AnsiColorMap . XTerm . getGreen ()   +   "";\"">hello world</span>"" ) ) ;  }
@ Test  void   testGreenCSS ()   throws  IOException   {  assertThat ( annotate ( ""\033[32mhello world"" ,  AnsiColorMap . CSS ) , is ( ""<span style=\""color: green;\"">hello world</span>"" ) ) ;  }
@ Test  void   testGreenOnWhite ()   throws  IOException   {  assertThat ( annotate ( ""\033[47;32mhello world"" ) , is ( ""<span style=\""background-color: #E5E5E5;\""><span style=\""color: #00CD00;\"">hello world</span></span>"" ) ) ;  }
@ Test  void   testGreenOnWhiteCSS ()   throws  IOException   {  assertThat ( annotate ( ""\033[47;32mhello world"" ,  AnsiColorMap . CSS ) , is ( ""<span style=\""background-color: white;\""><span style=\""color: green;\"">hello world</span></span>"" ) ) ;  }
@ Test  void   testGreenOnWhiteXTerm ()   throws  IOException   {  assertThat ( annotate ( ""\033[47;32mhello world"" ,  AnsiColorMap . XTerm ) , is ( ""<span style=\""background-color: ""  +   AnsiColorMap . XTerm . getWhite ()   +   "";\""><span style=\""color: ""  +   AnsiColorMap . XTerm . getGreen ()   +   "";\"">hello world</span></span>"" ) ) ;  }
@ Test  void   testResetForegroundColor ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[32mtic\033[1mtac\033[39mtoe"" , ""<span style=\""color: #00CD00;\"">tic<b>tac</b></span><b>toe</b>"" ) ;  }
@ Test  void   testForegroundColorHighIntensity ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[90mDark gray\033[0m"" ,  ""<span style=\""color: #4C4C4C;\"">Dark gray</span>"" ) ;  assertThatAnnotateIs ( ""\033[91mLight red\033[0m"" ,  ""<span style=\""color: #FF0000;\"">Light red</span>"" ) ;  assertThatAnnotateIs ( ""\033[92mLight green\033[0m"" ,  ""<span style=\""color: #00FF00;\"">Light green</span>"" ) ;  assertThatAnnotateIs ( ""\033[93mLight yellow\033[0m"" ,  ""<span style=\""color: #FFFF00;\"">Light yellow</span>"" ) ;  assertThatAnnotateIs ( ""\033[94mLight blue\033[0m"" ,  ""<span style=\""color: #4682B4;\"">Light blue</span>"" ) ;  assertThatAnnotateIs ( ""\033[95mLight magenta\033[0m"" ,  ""<span style=\""color: #FF00FF;\"">Light magenta</span>"" ) ;  assertThatAnnotateIs ( ""\033[96mLight cyan\033[0m"" ,  ""<span style=\""color: #00FFFF;\"">Light cyan</span>"" ) ;  assertThatAnnotateIs ( ""\033[97mWhite\033[0m"" ,  ""<span style=\""color: #FFFFFF;\"">White</span>"" ) ;  }
@ Test  void   testForegroundColorRgb ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[38;2;0;0;0mBlack\033[0m"" ,  ""<span style=\""color: #000000;\"">Black</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;255;0;0mRed\033[0m"" ,  ""<span style=\""color: #FF0000;\"">Red</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;0;255;0mGreen\033[0m"" ,  ""<span style=\""color: #00FF00;\"">Green</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;255;255;0mYellow\033[0m"" ,  ""<span style=\""color: #FFFF00;\"">Yellow</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;0;0;255mBlue\033[0m"" ,  ""<span style=\""color: #0000FF;\"">Blue</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;255;0;255mMagenta\033[0m"" ,  ""<span style=\""color: #FF00FF;\"">Magenta</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;0;255;255mCyan\033[0m"" ,  ""<span style=\""color: #00FFFF;\"">Cyan</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;255;255;255mWhite\033[0m"" ,  ""<span style=\""color: #FFFFFF;\"">White</span>"" ) ;  assertThatAnnotateIs ( ""\033[38;2;128;128;128mGray\033[0m"" ,  ""<span style=\""color: #808080;\"">Gray</span>"" ) ;  }
@ Test  void   testResetBackgroundColor ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[42mtic\033[1mtac\033[49mtoe"" , ""<span style=\""background-color: #00CD00;\"">tic<b>tac</b></span><b>toe</b>"" ) ;  }
@ Test  void   testBackgroundColorHighIntensity ()   throws  IOException   {  assertThatAnnotateIs ( ""\033[100mDark gray\033[0m"" ,  ""<span style=\""background-color: #4C4C4C;\"">Dark gray</span>"" ) ;  assertThatAnnotateIs ( ""\033[101mLight red\033[0m"" ,  ""<span style=\""background-color: #FF0000;\"">Light red</span>"" ) ;  assertThatAnnotateIs ( ""\033[102mLight green\033[0m"" ,  ""<span style=\""background-color: #00FF00;\"">Light green</span>"" ) ;  assertThatAnnotateIs ( ""\033[103mLight yellow\033[0m"" ,  ""<span style=\""background-color: #FFFF00;\"">Light yellow</span>"" ) ;  assertThatAnnotateIs ( ""\033[104mLight blue\033[0m"" ,  ""<span style=\""background-color: #4682B4;\"">Light blue</span>"" ) ;  assertThatAnnotateIs ( ""\033[105mLight magenta\033[0m"" ,  ""<span style=\""background-color: #FF00FF;\"">Light magenta</span>"" ) ;  assertThatAnnotateIs ( ""\033[106mLight cyan\033[0m"" ,  ""<span style=\""background-color: #00FFFF;\"">Light cyan</span>"" ) ;  assertThatAnnotateIs ( ""\033[107mWhite\033[0m"" ,  ""<span style=\""background-color: #FFFFFF;\"">White</span>"" ) ;  }
@ Test  void   testDefaultColors ()   throws  IOException   {  assertThat ( annotate ( ""\033[32mtic\033[1mtac\033[39mtoe"" ,  AnsiColorMap . VGA ) , is ( ""<div style=\""background-color: #000000;color: #AAAAAA;\"">""   +  ""<span style=\""color: #00AA00;\"">tic<b>tac</b></span><b>toe</b>""   +  ""</div>"" ) ) ;  }
@ Test  void   testConsoleNote ()   throws  IOException   {  assertThat ( annotate ( ConsoleNote . PREAMBLE_STR   +   ""hello world""   +   ConsoleNote . POSTAMBLE_STR ) , is ( ConsoleNote . PREAMBLE_STR   +   ""hello world""   +   ConsoleNote . POSTAMBLE_STR ) ) ;  }
@ Test  void   testResetOnOpen ()   throws  IOException   {  assertThat ( annotate ( ""\033[0;31;49mred\033[0m"" ) , is ( ""<span style=\""color: #CD0000;\"">red""   +  ""</span>"" ) ) ;  }
@ Test  void   testOverlapping ()   throws  IOException   {  assertThatAnnotateIs ( ""plain\033[32mgreen\033[1mboldgreen\033[4mulboldgreen\033[31mulboldred""   +  ""\033[22mulred\033[24mred"" , ""plain""   +  ""<span style=\""color: #00CD00;\"">""   +                      
@ Test  void   testResetCharacterSet ()   throws  IOException   {  assertThatAnnotateIs ( ""(\033(0)"" ,  ""()"" ) ;  assertThatAnnotateIs ( ""(\033)0)"" ,  ""()"" ) ;  }
@ Test  void   testFontDefault ()   throws  IOException   {  assertThatAnnotateIs ( ""(\033[10m)"" ,  ""()"" ) ;  }
private   void   assertThatAnnotateIs ( String   ansi ,  String   html )   throws  IOException   {  assertThat ( annotate ( ansi ) ,  is ( html ) ) ;  }
private   void   assertThatAnnotateIs ( AnsiColorMap   colorMap ,  String   ansi ,  String   html )   throws  IOException   {  assertThat ( annotate ( ansi ,  colorMap ) ,  is ( html ) ) ;  }
private   String   annotate ( String   text ,  AnsiColorMap   colorMap )   throws  IOException   {  final   ByteArrayOutputStream   bos   =  new   ByteArrayOutputStream () ;  AnsiHtmlOutputStream   ansi   =  new   AnsiHtmlOutputStream ( bos ,  colorMap ,  html  ->  {  try  {  bos . write ( html . getBytes ( UTF_8 ) ) ;  }   catch  ( IOException   e )   {  throw  new   RuntimeException ( ""error emitting HTML"" ,  e ) ;  }  } ) ;  ansi . write ( text . getBytes ( UTF_8 ) ) ;  ansi . close () ;  return  bos . toString ( UTF_8 . displayName () ) ;  }
private   String   annotate ( String   text )   throws  IOException   {  return  annotate ( text ,  AnsiColorMap . Default ) ;  }
@ Test  void   testPipelineStep ( JenkinsRule   jenkinsRule )   throws  Exception   {  WorkflowJob   p   =  jenkinsRule . jenkins . createProject ( WorkflowJob . class ,  ""p"" ) ;  p . setDefinition ( new   CpsFlowDefinition ( ""ansiColor('xterm') {\n""  +   ""  echo 'The following word is supposed to be \\u001B[31mred\\u001B[0m'\n""  +   "" echo \""TERM=${env.TERM}\""""  +   ""}"" ,  true ) ) ;  WorkflowRun   run   =  jenkinsRule . assertBuildStatusSuccess ( p . scheduleBuild2 ( 0 ) ) ;  StringWriter   writer   =  new   StringWriter () ;  assertTrue ( p . getLastBuild () . getLogText () . writeHtmlTo ( 0L ,  writer )   >   0 ) ;  String   html   =  writer . toString () ;  jenkinsRule . assertLogContains ( ""TERM=xterm"" ,  run ) ;  assertTrue ( html . replaceAll ( ""<!--.+?-->"" ,  """" ) . matches ( ""(?s).*<span style=\""color: #CD0000;\"">red</span>.*"" ) , ""Failed to match color attribute in following HTML log output:\n""   +   html ) ;  }
@ Issue ( ""JENKINS-61598"" )  @ Test  void   willNotLeakFormattingToMetadataLines ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   script   =  ""ansiColor('xterm') {\n""   +  ""    echo '\033[33mYellow words, white background.'\n""   +  ""    echo '\033[35mMagenta words, white background.'\n""   +  ""}"" ;  String   nl   =  System . lineSeparator () ;  assertOutputOnRunningPipeline ( jenkinsRule , Arrays . asList ( ""<span style=\""color: #CDCD00;\"">Yellow words, white background.""   +   nl   +   ""</span>"" , ""[Pipeline] echo"" , ""<span style=\""color: #CD00CD;\"">Magenta words, white background.""   +   nl   +   ""</span>"" , ""[Pipeline] }"" ) , Arrays . asList ( ""\033[33mYellow words, white background."" , ""<span style=\""color: #CDCD00;\"">[Pipeline] echo"" , ""\033[35mMagenta words, white background."" , ""<span style=\""color: #CD00CD;\"">[Pipeline] }""   +   nl   +   ""</span>"" ) , script ) ;  }
@ Test  void   willPrintAdditionalNlOnKubernetesPlugin ( JenkinsRule   jenkinsRule )   throws  Exception   {  ExtensionList . lookup ( DynamicContext . Typed . class ) . add ( 0 ,  new   SecretsMasker () ) ;  assertNlsOnRunningPipeline ( jenkinsRule ) ;  }
@ Test  void   willPrintAdditionalNlOnTimestamperPlugin ( JenkinsRule   jenkinsRule )   throws  Exception   {  ExtensionList . lookup ( TaskListenerDecorator . Factory . class ) . add ( 0 ,  new   GlobalDecorator () ) ;  assertNlsOnRunningPipeline ( jenkinsRule ) ;  }
@ Issue ( ""222"" )  @ Test  void   willPrintAdditionalNlOnLogstashPlugin ( JenkinsRule   jenkinsRule )   throws  Exception   {  ExtensionList . lookup ( TaskListenerDecorator . Factory . class ) . add ( 0 ,  new   hudson . plugins . ansicolor . mock . logstash . pipeline . GlobalDecorator () ) ;  assertNlsOnRunningPipeline ( jenkinsRule ) ;  }
@ Issue ( ""223"" )  @ Test  void   willPrintAdditionalNlOnPipelineMavenPlugin ( JenkinsRule   jenkinsRule )   throws  Exception   {  ExtensionList . lookup ( StepDescriptor . class ) . add ( 0 ,  new   WithMavenStep . DescriptorImpl () ) ;  assertNlsOnRunningPipeline ( jenkinsRule ) ;  }
@ Issue ( ""218"" )  @ Test  void   canUseAndReportDefaultColorMapName ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   script   =  ""ansiColor {\n""   +  ""    echo '\033[33mYellow words, white background.\033[0m'\n""   +  ""    echo \""TERM=${env.TERM}\""\n""   +  ""}"" ;  assertOutputOnRunningPipeline ( jenkinsRule , Arrays . asList ( ""<span style=\""color: #CDCD00;\"">Yellow words, white background.</span>"" , ""TERM=xterm"" ) , Arrays . asList ( ""\033[33mYellow words, white background."" , ""TERM=null"" ) , script ) ;  }
@ Issue ( ""JENKINS-66684"" )  @ Test  void   canGetConstructorParametersForSnippetGenerator ( JenkinsRule   jenkinsRule )   {  final   String   colorMapName   =  AnsiColorMap . VGA . getName () ;  final   AnsiColorStep   step   =  new   AnsiColorStep ( colorMapName ) ;  assertEquals ( colorMapName ,  step . getColorMapName () ) ;  }
private   void   assertOutputOnRunningPipeline ( JenkinsRule   jenkinsRule ,  Collection < String >   expectedOutput ,  Collection < String >   notExpectedOutput ,  String   pipelineScript )   throws  Exception   {  final   WorkflowJob   project   =  jenkinsRule . jenkins . createProject ( WorkflowJob . class ,  ""p"" ) ;  project . setDefinition ( new   CpsFlowDefinition ( pipelineScript ,  true ) ) ;  jenkinsRule . assertBuildStatusSuccess ( project . scheduleBuild2 ( 0 ) ) ;  StringWriter   writer   =  new   StringWriter () ;  assertTrue ( project . getLastBuild () . getLogText () . writeHtmlTo ( 0 ,  writer )   >   0 ) ;  final   String   html   =  writer . toString () . replaceAll ( ""<!--.+?-->"" ,  """" ) ;  for  ( String   expected   :  expectedOutput )   {  assertThat ( html ,  containsString ( expected ) ) ;  }  for  ( String   notExpected   :  notExpectedOutput )   {  assertThat ( html ,  not ( containsString ( notExpected ) ) ) ;  }  }
@ Test  void   testGetColorMapNameNull ( JenkinsRule   jenkinsRule )   {  AnsiColorBuildWrapper   instance   =  new   AnsiColorBuildWrapper ( null ) ;  assertEquals ( ""xterm"" ,  instance . getColorMapName () ) ;  }
@ Test  void   testGetColorMapNameVga ( JenkinsRule   jenkinsRule )   {  AnsiColorBuildWrapper   instance   =  new   AnsiColorBuildWrapper ( ""vga"" ) ;  assertEquals ( ""vga"" ,  instance . getColorMapName () ) ;  }
@ Test  void   testDecorateLogger ( JenkinsRule   jenkinsRule )   {  AnsiColorBuildWrapper   ansiColorBuildWrapper   =  new   AnsiColorBuildWrapper ( null ) ;  assertThat ( ansiColorBuildWrapper ,  instanceOf ( AnsiColorBuildWrapper . class ) ) ;  }
@ Override  public   boolean   perform ( AbstractBuild < ? ,  ? >   build ,  Launcher   launcher ,  BuildListener   listener )   throws  InterruptedException ,  IOException   {  listener . getLogger () . println ( ""\u001B[1;34mThis text should be bold and blue"" ) ;  listener . getLogger () . println ( ""Still bold and blue"" ) ;  listener . getLogger () . println ( ""\u001B[mThis text should be normal"" ) ;  return  true ;  }
@ Override  public   boolean   perform ( AbstractBuild < ? ,  ? >   build ,  Launcher   launcher ,  BuildListener   listener )   throws  InterruptedException ,  IOException   {  listener . getLogger () . println ( ""White on black"" ) ;  listener . getLogger () . println ( ""\u001B[1;34mBold and blue on black"" ) ;  listener . getLogger () . println ( ""Still bold and blue on black\u001B[mBack to white on black"" ) ;  return  true ;  }
@ Issue ( ""JENKINS-54133"" )  @ Test  void   testWorkflowWrap ( JenkinsRule   jenkinsRule )   throws  Exception   {  assumeFalse ( Functions . isWindows () ) ;  jenkinsRule . createSlave () ;  WorkflowJob   p   =  jenkinsRule . jenkins . createProject ( WorkflowJob . class ,  ""p"" ) ;  p . setDefinition ( new   CpsFlowDefinition ( ""node('!master') {\n""  +   ""  wrap([$class: 'AnsiColorBuildWrapper', 'colorMapName': 'XTerm']) {\n""  +   ""    sh(\""\""\""#!/bin/bash\n""  +   ""      printf 'The following word is supposed to be \\\\e[31mred\\\\e[0m\\\\n'\""\""\""\n""  +   ""    )\n""  +   ""  }\n""  +   ""}"" ,  false ) ) ;  jenkinsRule . assertBuildStatusSuccess ( p . scheduleBuild2 ( 0 ) ) ;  StringWriter   writer   =  new   StringWriter () ;  assertTrue ( p . getLastBuild () . getLogText () . writeHtmlTo ( 0L ,  writer )   >   0 ) ;  String   html   =  writer . toString () ;  assertTrue ( html . replaceAll ( ""<!--.+?-->"" ,  """" ) . matches ( ""(?s).*<span style=\""color: #CD0000;\"">red</span>.*"" ) , ""Failed to match color attribute in following HTML log output:\n""   +   html ) ;  }
@ Override  public   boolean   perform ( AbstractBuild < ? ,  ? >   build ,  Launcher   launcher ,  BuildListener   listener )   throws  InterruptedException ,  IOException   {  
@ Override  public   boolean   perform ( AbstractBuild < ? ,  ? >   build ,  Launcher   launcher ,  BuildListener   listener )   throws  InterruptedException ,  IOException   {  listener . getLogger () . println ( ""[Foo] \033[0m[\033[0m\033[0minfo\033[0m] \033[0m\033[0m\033[32m- this text is green\033[0m\033[0m"" ) ;  return  true ;  }
@ Test  void   canWorkWithMovingSequences ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   op1   =  ""Creating container_1"" ;  final   String   op2   =  ""Creating container_2"" ;  final   String   up2lines   =  csi ( 2 ,  CSI . CUU ) ;  final   String   down2lines   =  csi ( 2 ,  CSI . CUD ) ;  final   String   back7chars   =  csi ( 7 ,  CSI . CUB ) ;  final   String   forward4chars   =  csi ( 4 ,  CSI . CUF ) ;  final   Consumer < PrintStream >   inputProvider   =  stream  ->  {  stream . println ( op1   +   "" ..."" ) ;  stream . println ( op2   +   "" ..."" ) ;  stream . print ( up2lines ) ;  stream . print ( CLR ) ;  stream . print ( op1   +   "" ... ""   +   ""done\r"" ) ;  stream . print ( down2lines ) ;  stream . print ( back7chars ) ;  stream . print ( forward4chars ) ;  } ;  assertCorrectOutput ( jenkinsRule , Arrays . asList ( op1   +   "" ... done"" ,  op2   +   "" ..."" ) , Arrays . asList ( up2lines ,  CLR ,  down2lines ,  back7chars ,  forward4chars ) , inputProvider ) ;  }
@ Test  void   canWorkWithVariousCsiSequences ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   txt0   =  ""Test various sequences begin"" ;  final   List < String >   csiSequences   =  Arrays . stream ( CSI . values () ) . map ( csi  ->  switch (csi.paramsAmount )   { case  0   ->   csi ( csi ) ;  case  1   ->   csi ( 6 ,  csi ) ;  case  2   ->   csi ( 6 ,  4 ,  csi ) ;  default  ->   throw  new  IllegalArgumentException ( ""Not supported amount of params"" ) ;  } ) . toList () ;  final   String   txt1   =  ""Test various sequences end"" ;  final   Consumer < PrintStream >   inputProvider   =  stream  ->  {  stream . println ( txt0 ) ;  csiSequences . forEach ( stream :: println ) ;  stream . println ( txt1 ) ;  } ;  assertCorrectOutput ( jenkinsRule ,  Arrays . asList ( txt0 ,  txt1 ) ,  csiSequences ,  inputProvider ) ;  }
@ Issue ( ""158"" )  @ Test  void   canHandleSgrsWithMultipleOptions ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   input   =  ""\u001B[33mbanana_1  |\u001B[0m 19:59:14.353\u001B[0;38m [debug] Lager installed handler {lager_file_backend,\""banana.log\""} into lager_event\u001B[0m\n"" ;  final   Consumer < PrintStream >   inputProvider   =  stream  ->   stream . println ( input ) ;  assertCorrectOutput ( jenkinsRule , Collections . singletonList ( ""<span style=\""color: #CDCD00;\"">banana_1  |</span> 19:59:14.353 [debug] Lager installed handler {lager_file_backend,\""banana.log\""} into lager_event"" ) , Collections . singletonList ( ESC ) , inputProvider ) ;  }
@ Issue ( ""186"" )  @ Test  void   canHandleSgrsWithRgbColors ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   input   =  ""\u001B[1;38;5;4m[fe1.k8sf.atom.us-west-2 ]\u001B[0m\n\u001B[1;38;5;13m[fe1b.k8sf.atom.us-east-2]\u001B[0m"" ;  final   Consumer < PrintStream >   inputProvider   =  stream  ->   stream . println ( input ) ;  assertCorrectOutput ( jenkinsRule , Arrays . asList ( ""<b><span style=\""color: #1E90FF;\"">[fe1.k8sf.atom.us-west-2 ]</span></b>"" , ""<b><span style=\""color: #FF00FF;\"">[fe1b.k8sf.atom.us-east-2]</span></b>"" ) , Collections . singletonList ( ESC ) , inputProvider ) ;  }
private   static   String   csi ( CSI   csi )   {  return  csi ( """" ,  csi ) ;  }
private   static   String   csi ( int   n ,  CSI   csi )   {  return  csi ( String . valueOf ( n ) ,  csi ) ;  }
private   static   String   csi ( int   n ,  int   m ,  CSI   csi )   {  return  csi ( n   +   "";""   +   m ,  csi ) ;  }
private   static   String   csi ( String   nm ,  CSI   csi )   {  return  ESC   +   ""[""   +   nm   +   csi . code ;  }
private   static   String   sgr ( int ...   sgrParam )   {  return  ESC   +   ""[""   +   Arrays . stream ( sgrParam ) . boxed () . map ( String :: valueOf ) . collect ( Collectors . joining ( "";"" ) )   +   ""m"" ;  }
private   void   assertCorrectOutput ( JenkinsRule   rule ,  Collection < String >   expectedOutput ,  Collection < String >   notExpectedOutput ,  Consumer < PrintStream >   inputProvider )   throws  Exception   {  final   String   html   =  runBuildWithPlugin ( rule ,  inputProvider ) . replaceAll ( ""<!--.+?-->"" ,  """" ) ;  expectedOutput . forEach ( s  ->   assertThat ( html ,  containsString ( s ) ) ) ;  notExpectedOutput . forEach ( s  ->   assertThat ( ""Test failed for sequence: ""   +   s . replace ( ESC ,  ""ESC"" ) ,  html ,  not ( containsString ( s ) ) ) ) ;  }
@ Override  public   boolean   perform ( AbstractBuild < ? ,  ? >   build ,  Launcher   launcher ,  BuildListener   listener )   throws  InterruptedException ,  IOException   {  inputProvider . accept ( listener . getLogger () ) ;  return  true ;  }
@ BeforeEach  public   void   setUp ( JenkinsRule   jenkinsRule )   throws  Exception   {  this . jenkinsRule   =   jenkinsRule ;  descriptor   =   new   AnsiColorBuildWrapper . DescriptorImpl () ;  }
@ Test  void   canValidateCorrectInputData ()   throws  Exception   {  final   List < AnsiColorMap >   ansiColorMaps   =  Arrays . asList ( AnsiColorMap . XTerm ,  AnsiColorMap . CSS ) ;  final   String   globalMapName   =  ""xterm"" ;  final   String   colorMap   =  ""{'abc' : 123}"" ;  final   HashMap < String ,  String >   formData   =  new   HashMap <> () ;  formData . put ( ""colorMap"" ,  colorMap ) ;  formData . put ( ""globalColorMapName"" ,  ""   ""   +   globalMapName   +   "" "" ) ;  final   JSONObject   form   =  JSONObject . fromObject ( formData ) ;  when ( staplerRequest . getSubmittedForm () ) . thenReturn ( form ) ;  when ( staplerRequest . bindJSONToList ( eq ( AnsiColorMap . class ) ,  eq ( colorMap ) ) ) . thenReturn ( ansiColorMaps ) ;  assertTrue ( descriptor . configure ( staplerRequest ,  form ) ) ;  final   List < AnsiColorMap >   savedMaps   =  Arrays . asList ( descriptor . getColorMaps () ) ;  ansiColorMaps . forEach ( map  ->   assertTrue ( savedMaps . contains ( map ) ,  ""Expected map no there: ""   +   map ) ) ;  assertEquals ( globalMapName ,  descriptor . getGlobalColorMapName () ) ;  }
@ Test  void   emptyGlobalColorNameWontBeStored ()   throws  Exception   {  final   HashMap < String ,  String >   formData   =  new   HashMap <> () ;  final   String   colorMap   =  ""{'abc' : 123}"" ;  formData . put ( ""colorMap"" ,  colorMap ) ;  formData . put ( ""globalColorMapName"" ,  """" ) ;  final   JSONObject   form   =  JSONObject . fromObject ( formData ) ;  when ( staplerRequest . getSubmittedForm () ) . thenReturn ( form ) ;  when ( staplerRequest . bindJSONToList ( eq ( AnsiColorMap . class ) ,  eq ( colorMap ) ) ) . thenReturn ( Collections . emptyList () ) ;  assertTrue ( descriptor . configure ( staplerRequest ,  form ) ) ;  assertNull ( descriptor . getGlobalColorMapName () ) ;  }
@ Test  void   wontAllowGlobalColorNameTooLong ()   throws  Exception   {  final   HashMap < String ,  String >   formData   =  new   HashMap <> () ;  final   String   colorMap   =  ""{'abc' : 123}"" ;  formData . put ( ""colorMap"" ,  colorMap ) ;  formData . put ( ""globalColorMapName"" ,  Strings . repeat ( 'x' ,  257 ) ) ;  final   JSONObject   form   =  JSONObject . fromObject ( formData ) ;  when ( staplerRequest . getSubmittedForm () ) . thenReturn ( form ) ;  when ( staplerRequest . bindJSONToList ( eq ( AnsiColorMap . class ) ,  eq ( colorMap ) ) ) . thenReturn ( Collections . emptyList () ) ;  assertThrows ( Descriptor . FormException . class ,  ()  ->  descriptor . configure ( staplerRequest ,  form ) ) ;  }
@ Test  void   wontAllowColorNameTooLong ()   throws  Exception   {  final   String   tooLong   =  Strings . repeat ( 'x' ,  257 ) ;  assertAllColorMapsInvalid ( new   AnsiColorMap [] { new   AnsiColorMap ( tooLong , ""#C4A000"" ,  ""#CC0000"" ,  ""#4E9A06"" ,  ""#C4A000"" ,  ""#3465A4"" ,  ""#75507B"" ,  ""#06989A"" ,  ""#D3D7CF"" , ""#2E3436"" ,  ""#CC0000"" ,  ""#4E9A06"" ,  ""#C4A000"" ,  ""#3465A4"" ,  ""#75507B"" ,  ""#06989A"" ,  ""#D3D7CF"" , AnsiColorMap . Color . WHITE . ordinal () ,  AnsiColorMap . Color . BLACK . ordinal () ) } ) ;  }
@ Test  void   wontAllowGlobalColorNameNotMatchingOneColorMap ()   throws  Exception   {  final   List < AnsiColorMap >   ansiColorMaps   =  Arrays . asList ( AnsiColorMap . XTerm ,  AnsiColorMap . VGA ) ;  final   HashMap < String ,  String >   formData   =  new   HashMap <> () ;  final   String   colorMap   =  ""{'abc' : 123}"" ;  formData . put ( ""colorMap"" ,  colorMap ) ;  formData . put ( ""globalColorMapName"" ,  ""NotExistingColorMap"" ) ;  final   JSONObject   form   =  JSONObject . fromObject ( formData ) ;  when ( staplerRequest . getSubmittedForm () ) . thenReturn ( form ) ;  when ( staplerRequest . bindJSONToList ( eq ( AnsiColorMap . class ) ,  eq ( colorMap ) ) ) . thenReturn ( ansiColorMaps ) ;  assertThrows ( Descriptor . FormException . class ,  ()  ->  descriptor . configure ( staplerRequest ,  form ) ) ;  }
 <argument pos:start=""""632:98"""" pos:end=""""632:106""""><expr pos:start=""""632:98"""" pos:end=""""632:106""""><literal type=""""string"""" pos:start=""""632:98"""" pos:end=""""632:106"""">""""#D3D7CF""""</literal></expr></argument>
 <argument pos:start=""""637:54"""" pos:end=""""637:62""""><expr pos:start=""""637:54"""" pos:end=""""637:62""""><literal type=""""string"""" pos:start=""""637:54"""" pos:end=""""637:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""638:54"""" pos:end=""""638:62""""><expr pos:start=""""638:54"""" pos:end=""""638:62""""><literal type=""""string"""" pos:start=""""638:54"""" pos:end=""""638:62"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""643:54"""" pos:end=""""643:62""""><expr pos:start=""""643:54"""" pos:end=""""643:62""""><literal type=""""string"""" pos:start=""""643:54"""" pos:end=""""643:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""644:47"""" pos:end=""""644:55""""><expr pos:start=""""644:47"""" pos:end=""""644:55""""><literal type=""""string"""" pos:start=""""644:47"""" pos:end=""""644:55"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""649:54"""" pos:end=""""649:62""""><expr pos:start=""""649:54"""" pos:end=""""649:62""""><literal type=""""string"""" pos:start=""""649:54"""" pos:end=""""649:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""650:47"""" pos:end=""""650:55""""><expr pos:start=""""650:47"""" pos:end=""""650:55""""><literal type=""""string"""" pos:start=""""650:47"""" pos:end=""""650:55"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""655:54"""" pos:end=""""655:62""""><expr pos:start=""""655:54"""" pos:end=""""655:62""""><literal type=""""string"""" pos:start=""""655:54"""" pos:end=""""655:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""656:47"""" pos:end=""""656:55""""><expr pos:start=""""656:47"""" pos:end=""""656:55""""><literal type=""""string"""" pos:start=""""656:47"""" pos:end=""""656:55"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""661:54"""" pos:end=""""661:62""""><expr pos:start=""""661:54"""" pos:end=""""661:62""""><literal type=""""string"""" pos:start=""""661:54"""" pos:end=""""661:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""662:54"""" pos:end=""""662:55""""><expr pos:start=""""662:54"""" pos:end=""""662:55""""><literal type=""""string"""" pos:start=""""662:54"""" pos:end=""""662:55"""">""""""""</literal></expr></argument>
 <argument pos:start=""""667:54"""" pos:end=""""667:62""""><expr pos:start=""""667:54"""" pos:end=""""667:62""""><literal type=""""string"""" pos:start=""""667:54"""" pos:end=""""667:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""668:54"""" pos:end=""""668:62""""><expr pos:start=""""668:54"""" pos:end=""""668:62""""><literal type=""""string"""" pos:start=""""668:54"""" pos:end=""""668:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""673:54"""" pos:end=""""673:62""""><expr pos:start=""""673:54"""" pos:end=""""673:62""""><literal type=""""string"""" pos:start=""""673:54"""" pos:end=""""673:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""674:54"""" pos:end=""""674:62""""><expr pos:start=""""674:54"""" pos:end=""""674:62""""><literal type=""""string"""" pos:start=""""674:54"""" pos:end=""""674:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""679:54"""" pos:end=""""679:62""""><expr pos:start=""""679:54"""" pos:end=""""679:62""""><literal type=""""string"""" pos:start=""""679:54"""" pos:end=""""679:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""680:54"""" pos:end=""""680:62""""><expr pos:start=""""680:54"""" pos:end=""""680:62""""><literal type=""""string"""" pos:start=""""680:54"""" pos:end=""""680:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""685:54"""" pos:end=""""685:62""""><expr pos:start=""""685:54"""" pos:end=""""685:62""""><literal type=""""string"""" pos:start=""""685:54"""" pos:end=""""685:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""686:54"""" pos:end=""""686:62""""><expr pos:start=""""686:54"""" pos:end=""""686:62""""><literal type=""""string"""" pos:start=""""686:54"""" pos:end=""""686:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""742:54"""" pos:end=""""742:62""""><expr pos:start=""""742:54"""" pos:end=""""742:62""""><literal type=""""string"""" pos:start=""""742:54"""" pos:end=""""742:62"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""748:54"""" pos:end=""""748:62""""><expr pos:start=""""748:54"""" pos:end=""""748:62""""><literal type=""""string"""" pos:start=""""748:54"""" pos:end=""""748:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""749:54"""" pos:end=""""749:62""""><expr pos:start=""""749:54"""" pos:end=""""749:62""""><literal type=""""string"""" pos:start=""""749:54"""" pos:end=""""749:62"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""755:54"""" pos:end=""""755:62""""><expr pos:start=""""755:54"""" pos:end=""""755:62""""><literal type=""""string"""" pos:start=""""755:54"""" pos:end=""""755:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""756:52"""" pos:end=""""756:60""""><expr pos:start=""""756:52"""" pos:end=""""756:60""""><literal type=""""string"""" pos:start=""""756:52"""" pos:end=""""756:60"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""762:54"""" pos:end=""""762:62""""><expr pos:start=""""762:54"""" pos:end=""""762:62""""><literal type=""""string"""" pos:start=""""762:54"""" pos:end=""""762:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""763:52"""" pos:end=""""763:60""""><expr pos:start=""""763:52"""" pos:end=""""763:60""""><literal type=""""string"""" pos:start=""""763:52"""" pos:end=""""763:60"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""769:54"""" pos:end=""""769:62""""><expr pos:start=""""769:54"""" pos:end=""""769:62""""><literal type=""""string"""" pos:start=""""769:54"""" pos:end=""""769:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""770:52"""" pos:end=""""770:60""""><expr pos:start=""""770:52"""" pos:end=""""770:60""""><literal type=""""string"""" pos:start=""""770:52"""" pos:end=""""770:60"""">""""#C4A000""""</literal></expr></argument>
 <argument pos:start=""""776:54"""" pos:end=""""776:62""""><expr pos:start=""""776:54"""" pos:end=""""776:62""""><literal type=""""string"""" pos:start=""""776:54"""" pos:end=""""776:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""777:54"""" pos:end=""""777:60""""><expr pos:start=""""777:54"""" pos:end=""""777:60""""><name pos:start=""""777:54"""" pos:end=""""777:60"""">tooLong</name></expr></argument>
 <argument pos:start=""""783:54"""" pos:end=""""783:62""""><expr pos:start=""""783:54"""" pos:end=""""783:62""""><literal type=""""string"""" pos:start=""""783:54"""" pos:end=""""783:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""784:54"""" pos:end=""""784:62""""><expr pos:start=""""784:54"""" pos:end=""""784:62""""><literal type=""""string"""" pos:start=""""784:54"""" pos:end=""""784:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""790:54"""" pos:end=""""790:62""""><expr pos:start=""""790:54"""" pos:end=""""790:62""""><literal type=""""string"""" pos:start=""""790:54"""" pos:end=""""790:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""791:54"""" pos:end=""""791:62""""><expr pos:start=""""791:54"""" pos:end=""""791:62""""><literal type=""""string"""" pos:start=""""791:54"""" pos:end=""""791:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""797:54"""" pos:end=""""797:62""""><expr pos:start=""""797:54"""" pos:end=""""797:62""""><literal type=""""string"""" pos:start=""""797:54"""" pos:end=""""797:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""798:54"""" pos:end=""""798:62""""><expr pos:start=""""798:54"""" pos:end=""""798:62""""><literal type=""""string"""" pos:start=""""798:54"""" pos:end=""""798:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""804:54"""" pos:end=""""804:62""""><expr pos:start=""""804:54"""" pos:end=""""804:62""""><literal type=""""string"""" pos:start=""""804:54"""" pos:end=""""804:62"""">""""#3465A4""""</literal></expr></argument>
 <argument pos:start=""""805:54"""" pos:end=""""805:62""""><expr pos:start=""""805:54"""" pos:end=""""805:62""""><literal type=""""string"""" pos:start=""""805:54"""" pos:end=""""805:62"""">""""#3465A4""""</literal></expr></argument>
private   void   assertAllColorMapsInvalid ( AnsiColorMap []   invalidColorMaps )   throws  ServletException   {  for  ( AnsiColorMap   invalidColorMap   :  invalidColorMaps )   {  final   List < AnsiColorMap >   ansiColorMaps   =  Arrays . asList ( AnsiColorMap . XTerm ,  invalidColorMap ) ;  final   HashMap < String ,  String >   formData   =  new   HashMap <> () ;  final   String   colorMap   =  ""{'abc' : 123}"" ;  formData . put ( ""colorMap"" ,  colorMap ) ;  final   JSONObject   form   =  JSONObject . fromObject ( formData ) ;  when ( staplerRequest . getSubmittedForm () ) . thenReturn ( form ) ;  when ( staplerRequest . bindJSONToList ( eq ( AnsiColorMap . class ) ,  eq ( colorMap ) ) ) . thenReturn ( ansiColorMaps ) ;  assertThrows ( Descriptor . FormException . class ,  ()  ->   descriptor . configure ( staplerRequest ,  form ) ,  ""Invalid color map has not triggered exception: ""   +   invalidColorMap ) ;  }  }
@ Test  void   testGlobalPipelineColorMap ( JenkinsRule   jenkinsRule )   throws  Exception   {  Jenkins . get () . getDescriptorByType ( AnsiColorBuildWrapper . DescriptorImpl . class ) . setGlobalColorMapName ( ""xterm"" ) ;  WorkflowJob   p   =  jenkinsRule . jenkins . createProject ( WorkflowJob . class ,  ""p"" ) ;  p . setDefinition ( new   CpsFlowDefinition ( ""echo 'The following word is supposed to be \\u001B[31mred\\u001B[0m'"" ,  true ) ) ;  jenkinsRule . assertBuildStatusSuccess ( p . scheduleBuild2 ( 0 ) ) ;  StringWriter   writer   =  new   StringWriter () ;  assertTrue ( p . getLastBuild () . getLogText () . writeHtmlTo ( 0L ,  writer )   >   0 ) ;  String   html   =  writer . toString () ;  assertTrue ( html . replaceAll ( ""<!--.+?-->"" ,  """" ) . matches ( ""(?s).*<span style=\""color: #CD0000;\"">red</span>.*"" ) , ""Failed to match color attribute in following HTML log output:\n""   +   html ) ;  }
@ Test  void   testNoGlobalPipelineColorMap ( JenkinsRule   jenkinsRule )   throws  Exception   {  Jenkins . get () . getDescriptorByType ( AnsiColorBuildWrapper . DescriptorImpl . class ) . setGlobalColorMapName ( null ) ;  WorkflowJob   p   =  jenkinsRule . jenkins . createProject ( WorkflowJob . class ,  ""p"" ) ;  p . setDefinition ( new   CpsFlowDefinition ( ""echo 'The following word is supposed to be \\u001B[31mred\\u001B[0m'"" ,  true ) ) ;  jenkinsRule . assertBuildStatusSuccess ( p . scheduleBuild2 ( 0 ) ) ;  StringWriter   writer   =  new   StringWriter () ;  assertTrue ( p . getLastBuild () . getLogText () . writeHtmlTo ( 0L ,  writer )   >   0 ) ;  String   html   =  writer . toString () ;  assertFalse ( html . replaceAll ( ""<!--.+?-->"" ,  """" ) . matches ( ""(?s).*<span style=\""color: #CD0000;\"">red</span>.*"" ) , ""Color attribute was applied in following HTML log output even though the color map was not globally enabled:\n""   +   html ) ;  }
@ Test  void   canTriggerFunctionalityTimestamperFirst ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   script   =  ""timestamps {""   +  ""ansiColor('xterm') {""   +  ""echo '\033[34mHello\033[0m \033[33mcolorful\033[0m \033[35mworld!\033[0m'""   +  ""}""   +  ""}"" ;  canTriggerFunctionality ( jenkinsRule ,  script ) ;  }
@ Test  void   canTriggerFunctionalityTimestamperLast ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   script   =  ""ansiColor('xterm') {""   +  ""timestamps {""   +  ""echo '\033[34mHello\033[0m \033[33mcolorful\033[0m \033[35mworld!\033[0m'""   +  ""}""   +  ""}"" ;  canTriggerFunctionality ( jenkinsRule ,  script ) ;  }
private   void   canTriggerFunctionality ( JenkinsRule   jenkinsRule ,  String   script )   throws  Exception   {  assertOutputOnRunningPipeline ( jenkinsRule , Arrays . asList ( ""<span style=\""color: #1E90FF;\"">Hello</span>"" , ""<span style=\""color: #CDCD00;\"">colorful</span>"" , ""<span style=\""color: #CD00CD;\"">world!</span>"" ) , Arrays . asList ( ""\033[34mHello"" , ""\033[33mcolorful"" , ""\033[35mworld!"" ) , script , false ) ;  }
@ Test  void   testDeserialize_0_4_1 ()   {  assertNotNull ( getClass () . getResource ( ""/AnsiColorMap-0.4.1.xml"" ) ,  ""Test file missing"" ) ;  XStream2   xs2   =  new   XStream2 () ;  InputStream   is   =  getClass () . getResourceAsStream ( ""/AnsiColorMap-0.4.1.xml"" ) ;  AnsiColorMap   deserializedColorMap   =  ( AnsiColorMap )   xs2 . fromXML ( is ) ;  AnsiColorMap   colorMap   =  new   AnsiColorMap ( ""xterm"" , ""#000000"" ,  ""#CD0000"" ,  ""#00CD00"" ,  ""#CDCD00"" ,  ""#1E90FF"" ,  ""#CD00CD"" ,  ""#00CDCD"" ,  ""#E5E5E5"" , ""#4C4C4C"" ,  ""#FF0000"" ,  ""#00FF00"" ,  ""#FFFF00"" ,  ""#4682B4"" ,  ""#FF00FF"" ,  ""#00FFFF"" ,  ""#FFFFFF"" , null ,  null ) ;  assertEquals ( deserializedColorMap ,  colorMap ) ;  }
protected   void   assertOutputOnRunningPipeline ( JenkinsRule   jenkinsRule , BooleanSupplier   assumption , String   expectedOutput , String   notExpectedOutput , String   pipelineScript , boolean   useShortLog , Map < String ,  String >   properties )   throws  Exception   {  assertOutputOnRunningPipeline ( jenkinsRule ,  assumption ,  Collections . singletonList ( expectedOutput ) ,  Collections . singletonList ( notExpectedOutput ) ,  pipelineScript ,  useShortLog ,  properties ) ;  }
protected   void   assertOutputOnRunningPipeline ( JenkinsRule   jenkinsRule ,  Collection < String >   expectedOutput ,  Collection < String >   notExpectedOutput ,  String   pipelineScript ,  boolean   useShortLog )   throws  Exception   {  assertOutputOnRunningPipeline ( jenkinsRule ,  ()  ->   true ,  expectedOutput ,  notExpectedOutput ,  pipelineScript ,  useShortLog ,  Collections . emptyMap () ) ;  }
protected   void   assertOutputOnRunningPipeline ( JenkinsRule   jenkinsRule ,  Collection < String >   expectedOutput ,  Collection < String >   notExpectedOutput ,  String   pipelineScript ,  boolean   useShortLog ,  Map < String ,  String >   properties )   throws  Exception   {  assertOutputOnRunningPipeline ( jenkinsRule ,  ()  ->   true ,  expectedOutput ,  notExpectedOutput ,  pipelineScript ,  useShortLog ,  properties ) ;  }
public   static   String   repeat ( String   s ,  int   times )   {  return  IntStream . range ( 0 ,  times ) . mapToObj ( i  ->   s ) . collect ( Collectors . joining () ) ;  }
@ CheckForNull  @ Override  public   TaskListenerDecorator   of ( @ NonNull   FlowExecutionOwner   owner )   {  return  null ;  }
@ NonNull  @ Override  protected   Class < String >   type ()   {  return  String . class ;  }
@ CheckForNull  @ Override  protected   String   get ( DelegatedContext   context )   throws  IOException ,  InterruptedException   {  return  null ;  }
@ Override  public   StepExecution   start ( StepContext   stepContext )   throws  Exception   {  return  null ;  }
@ Override  public   Set < ?   extends  Class < ? > >   getRequiredContext ()   {  return  null ;  }
@ Override  public   String   getFunctionName ()   {  return  ""fake function"" ;  }
@ BeforeEach  void   setUp ()   throws  Exception   {  shortlogActionCreator   =   new   ShortlogActionCreator ( lineIdentifier ,  ""\n"" ) ;  }
@ Test  void   canCreateActionForShortlog ()   {  final   String   shortlogLine   =  ""\u001B[3B\u001B[2A\u001B[2K \u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold ""   +  ""\u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold ""   +  ""\u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold ""   +  ""\u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold ""   +  ""\u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold ""   +  ""\u001B[92m\u001B[22mlightgreen normal\u001B[0m \u001B[92m\u001B[1mlightgreen bold\n"" ;  canCreateActionForShortlog ( shortlogActionCreator ,  shortlogLine ,  ""testlog.log"" ,  true ) ;  }
@ Test  void   canCreateActionForShortlogBreakLines ()   {  canCreateActionForShortlog ( shortlogActionCreator ,  ""[Pipeline] echo\n"" ,  ""testlog.log"" ,  false ) ;  }
@ Test  void   canCreateActionForShortlogForWindowsBreakLines ()   {  final   String   eol   =  ""\r\n"" ;  canCreateActionForShortlog ( new   ShortlogActionCreator ( lineIdentifier ,  eol ) ,  ""[Pipeline] echo""   +   eol ,  ""testlog-crlf.log"" ,  false ) ;  }
@ Test  void   wontCreateActionIfBuildHasNoStartActions ()   {  final   boolean []   keepLinesWholeOptions   =  { true ,  false } ;  for  ( boolean   keepLinesWhole   :  keepLinesWholeOptions )   {  final   URL   inputFile   =  getClass () . getResource ( String . join ( ""/"" ,  """" ,  getClass () . getName () . replace ( '.' ,  '/' ) ,  ""testlog.log"" ) ) ;  assumeTrue ( inputFile   !=   null ) ;  final   File   file   =  new   File ( inputFile . getFile () ) ;  assertNull ( shortlogActionCreator . createActionForShortlog ( file ,  new   HashMap <> () ,  3 ,  keepLinesWhole ,  0 ) ) ;  verify ( lineIdentifier ,  never () ) . hash ( anyString () ,  anyLong () ) ;  }  }
@ Test  void   wontCreateActionIfNoCorrespondingNotesArePresent ()   {  final   boolean []   keepLinesWholeOptions   =  { true ,  false } ;  for  ( boolean   keepLinesWhole   :  keepLinesWholeOptions )   {  final   HashMap < String ,  ColorizedAction >   startActions   =  new   HashMap <> () ;  startActions . put ( ConsoleNote . PREAMBLE_STR   +   ""<mock-serialized-note-start0>"" ,  new   ColorizedAction ( ""css"" ,  ColorizedAction . Command . START ) ) ;  startActions . put ( ConsoleNote . PREAMBLE_STR   +   ""<mock-serialized-note-stop0>"" ,  new   ColorizedAction ( ""css"" ,  ColorizedAction . Command . STOP ) ) ;  final   URL   inputFile   =  getClass () . getResource ( String . join ( ""/"" ,  """" ,  getClass () . getName () . replace ( '.' ,  '/' ) ,  ""testlog-no-notes.log"" ) ) ;  assumeTrue ( inputFile   !=   null ) ;  final   File   file   =  new   File ( inputFile . getFile () ) ;  assertNull ( shortlogActionCreator . createActionForShortlog ( file ,  startActions ,  3 ,  keepLinesWhole ,  0 ) ) ;  verify ( lineIdentifier ,  never () ) . hash ( anyString () ,  anyLong () ) ;  }  }
@ Test  void   wontCreateActionIfNoLogFileIsPresent ()   {  final   boolean []   keepLinesWholeOptions   =  { true ,  false } ;  for  ( boolean   keepLinesWhole   :  keepLinesWholeOptions )   {  final   HashMap < String ,  ColorizedAction >   startActions   =  new   HashMap <> () ;  startActions . put ( ConsoleNote . PREAMBLE_STR   +   ""<mock-serialized-note-start0>"" ,  new   ColorizedAction ( ""css"" ,  ColorizedAction . Command . START ) ) ;  final   File   file   =  new   File ( ""non-existing.log"" ) ;  assertNull ( shortlogActionCreator . createActionForShortlog ( file ,  startActions ,  3 ,  keepLinesWhole ,  0 ) ) ;  verify ( lineIdentifier ,  never () ) . hash ( anyString () ,  anyLong () ) ;  }  }
@ Test  void   wontCreateActionIfActionIsNotActiveAtShortlogLimit ()   {  final   boolean []   keepLinesWholeOptions   =  { true ,  false } ;  for  ( boolean   keepLinesWhole   :  keepLinesWholeOptions )   {  final   URL   inputFile   =  getClass () . getResource ( String . join ( ""/"" ,  """" ,  getClass () . getName () . replace ( '.' ,  '/' ) ,  ""testlog-action-not-active.log"" ) ) ;  assumeTrue ( inputFile   !=   null ) ;  final   File   file   =  new   File ( inputFile . getFile () ) ;  final   HashMap < String ,  ColorizedAction >   startActions   =  new   HashMap <> () ;  startActions . put ( ConsoleNote . PREAMBLE_STR   +   ""<mock-serialized-note-start>"" ,  new   ColorizedAction ( ""css"" ,  ColorizedAction . Command . START ) ) ;  startActions . put ( ConsoleNote . PREAMBLE_STR   +   ""<mock-serialized-note-stop>"" ,  new   ColorizedAction ( ""css"" ,  ColorizedAction . Command . STOP ) ) ;  assertNull ( shortlogActionCreator . createActionForShortlog ( file ,  startActions ,  3 ,  keepLinesWhole ,  0 ) ) ;  verify ( lineIdentifier ,  never () ) . hash ( anyString () ,  anyLong () ) ;  }  }
@ Test  void   canCreateActionForShortlogOnLogLineExceedingBufferSize ()   {  final   String   s   =  ""[Pipeline]  echo a very very very long line,a very very very long line,a very very very long line,a very very very long line,a very very very long line"" ;  canCreateActionForShortlog ( shortlogActionCreator ,  s   +   ""\n"" ,  ""testlog-long.log"" ,  true ) ;  }
@ Test  void   canCreateActionForShortlogOnLogLineExceedingBufferSizeBreakLines ()   {  final   String   s   =  ""[Pipeline]  echo a very very very long line,a very very very long line,a very very very long line,a very very very long line,a very very very long line"" ;  canCreateActionForShortlog ( shortlogActionCreator ,  s   +   ""\n"" ,  ""testlog-long.log"" ,  false ) ;  }
@ BeforeEach  void   setUp ()   throws  Exception   {  lineIdentifier   =   new   LineIdentifier () ;  }
@ Test  void   canHashLine ()   {  assertEquals ( ""ojq32twB56Mha38FSpsOvwxZDdkOKa/SveGHDC4tgHY="" ,  lineIdentifier . hash ( ""test line 123"" ,  735 ) ) ;  }
@ Test  void   canDetermineIsEqualPositive ()   {  assertTrue ( lineIdentifier . isEqual ( ""\u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m"" ,  67 ,  ""1mo5/lFK3s3+qaz1vK3o62k+EAJkd8Q0j3dMRH8Wkh4="" ) ) ;  }
@ Test  void   canDetermineIsEqualNegative ()   {  assertFalse ( lineIdentifier . isEqual ( ""\u001B[92m\u001B[1mlightgreen bold \u001B[92m\u001B[22mlightgreen normal\u001B[0m"" ,  67 ,  ""bogus"" ) ) ;  }
@ Test  void   canAnnotateLongLogOutputInShortlogLinesWholeFalse ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   script   =  ""ansiColor('xterm') {\n""   +  repeat ( ""echo '\033[32m""   +   AS_1K   +   ""\033[0m'\n"" ,  150 )   +  ""}"" ;  final   Map < String ,  String >   properties   =  new   HashMap <> () ;  properties . put ( ShortlogActionCreator . PROP_LINES_WHOLE ,  ""false"" ) ;  BooleanSupplier   brokenLinesJenkins   =  ()  ->   Optional . ofNullable ( Jenkins . getVersion () )  . orElse ( ShortlogActionCreator . LINES_WHOLE_SINCE_VERSION )  . isOlderThan ( ShortlogActionCreator . LINES_WHOLE_SINCE_VERSION ) ;  assertOutputOnRunningPipeline ( jenkinsRule ,  brokenLinesJenkins ,  ""<span style=\""color: #00CD00;\"">""   +   AS_1K   +   ""</span>"" ,  ""\033"" ,  script ,  true ,  properties ) ;  }
@ Test  @ Disabled ( ""Needs adjustments for Jenkins > 2.260"" )  void   canAnnotateLongLogOutputInShortlogLinesWholeTrue ( JenkinsRule   jenkinsRule )   throws  Exception   {  final   String   script   =  ""ansiColor('xterm') {\n""   +  repeat ( ""echo '\033[32m""   +   AS_1K   +   ""\033[0m'\n"" ,  150 )   +  ""echo 'Abc'\n""   +  ""}"" ;  final   Map < String ,  String >   properties   =  new   HashMap <> () ;  properties . put ( ShortlogActionCreator . PROP_LINES_WHOLE ,  ""true"" ) ;  BooleanSupplier   wholeLinesJenkins   =  ()  ->   Optional . ofNullable ( Jenkins . getVersion () )  . orElse ( ShortlogActionCreator . LINES_WHOLE_SINCE_VERSION )  . isNewerThan ( ShortlogActionCreator . LINES_WHOLE_SINCE_VERSION ) ;  assertOutputOnRunningPipeline ( jenkinsRule ,  wholeLinesJenkins ,  ""<span style=\""color: #00CD00;\"">""   +   AS_1K   +   ""</span>"" ,  ""\033"" ,  script ,  true ,  properties ) ;  }
@ BeforeEach  void   setUp ()   throws  Exception   {  when ( buildRunSingleStart . getActions ( eq ( ColorizedAction . class ) ) ) . thenReturn ( Arrays . asList ( ACTION_0 , ACTION_1 , ACTION_2 ) ) ;  when ( buildRunMultipleStarts . getActions ( eq ( ColorizedAction . class ) ) ) . thenReturn ( Arrays . asList ( ACTION_0 , ACTION_1 , ACTION_2 , ACTION_3 , ACTION_4 ) ) ;  when ( buildRunOneCurrent . getActions ( eq ( ColorizedAction . class ) ) ) . thenReturn ( Arrays . asList ( ACTION_0 , ACTION_5 ) ) ;  colorizedAction   =   new   ColorizedAction ( ""vga"" ,  ColorizedAction . Command . START ) ;  }
@ Test  void   canInitAndGetProperties ()   {  assertNotNull ( colorizedAction . getId () ) ;  assertEquals ( ""vga"" ,  colorizedAction . getColorMapName () ) ;  assertEquals ( ColorizedAction . Command . START ,  colorizedAction . getCommand () ) ;  }
@ Test  void   canParseActionSingleStart ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  markupText . addMarkup ( 0 ,  TAG_ACTION_BEGIN   +   ""\""""   +   ACTION_1 . getId ()   +   ""\""""   +   TAG_ACTION_END ) ;  assertEquals ( ACTION_1 ,  ColorizedAction . parseAction ( markupText ,  buildRunSingleStart ) ) ;  }
@ Test  void   willNotTriggerStartIfThereIsExactlyOneStartActionAndNoCorrespondingAnnotation ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  assertEquals ( CONTINUE ,  ColorizedAction . parseAction ( markupText ,  buildRunSingleStart ) ) ;  }
@ Test  void   willReturnDefaultIfLogAnnotationPointsToNonexistentActionSingleStart ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  markupText . addMarkup ( 0 ,  TAG_ACTION_BEGIN   +   ""\""identifier_not_in_actions\""""   +   TAG_ACTION_END ) ;  assertEquals ( CONTINUE ,  ColorizedAction . parseAction ( markupText ,  buildRunSingleStart ) ) ;  }
@ Test  void   willReturnCommandIgnoreOnPipelineInternalLineSingleStart ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Some internal line"" ) ;  markupText . addMarkup ( 0 ,  ""<span class=\""pipeline-new-node\"">"" ) ;  final   ColorizedAction   colorizedAction   =  ColorizedAction . parseAction ( markupText ,  buildRunSingleStart ) ;  assertEquals ( ColorizedAction . Command . IGNORE ,  colorizedAction . getCommand () ) ;  }
@ Test  void   canParseActionMultipleStarts ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  markupText . addMarkup ( 0 ,  TAG_ACTION_BEGIN   +   ""\""""   +   ACTION_3 . getId ()   +   ""\""""   +   TAG_ACTION_END ) ;  assertEquals ( ACTION_3 ,  ColorizedAction . parseAction ( markupText ,  buildRunMultipleStarts ) ) ;  }
@ Test  void   willReturnDefaultIfLogDoesntContainAnnotation ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  assertEquals ( CONTINUE ,  ColorizedAction . parseAction ( markupText ,  buildRunMultipleStarts ) ) ;  }
@ Test  void   willReturnDefaultIfLogAnnotationPointsToNonexistentActionMultipleStarts ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  markupText . addMarkup ( 0 ,  TAG_ACTION_BEGIN   +   ""\""identifier_not_in_actions\""""   +   TAG_ACTION_END ) ;  assertEquals ( CONTINUE ,  ColorizedAction . parseAction ( markupText ,  buildRunMultipleStarts ) ) ;  }
@ Test  void   willReturnCommandIgnoreOnPipelineInternalLineMultipleStarts ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""Some internal line"" ) ;  markupText . addMarkup ( 0 ,  ""<span class=\""pipeline-new-node\"">"" ) ;  final   ColorizedAction   colorizedAction   =  ColorizedAction . parseAction ( markupText ,  buildRunMultipleStarts ) ;  assertEquals ( ColorizedAction . Command . IGNORE ,  colorizedAction . getCommand () ) ;  }
@ Test  void   canParseActionCurrentWhileBuildRunning ()   {  when ( buildRunOneCurrent . isBuilding () ) . thenReturn ( true ) ;  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  assertEquals ( ACTION_5 ,  ColorizedAction . parseAction ( markupText ,  buildRunOneCurrent ) ) ;  }
@ Test  void   wontParseActionCurrentWhileBuildNotRunning ()   {  when ( buildRunOneCurrent . isBuilding () ) . thenReturn ( false ) ;  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  assertEquals ( CONTINUE ,  ColorizedAction . parseAction ( markupText ,  buildRunOneCurrent ) ) ;  }
@ Test  void   wontParseActionCurrentWhileBuildRunningButNoCurrentAction ()   {  when ( buildRunSingleStart . isBuilding () ) . thenReturn ( true ) ;  final   MarkupText   markupText   =  new   MarkupText ( ""Log line"" ) ;  assertEquals ( CONTINUE ,  ColorizedAction . parseAction ( markupText ,  buildRunSingleStart ) ) ;  }
@ BeforeEach  void   setUp ()   throws  Exception   {  when ( colorizedAction . getId () ) . thenReturn ( UUID . toString () ) ;  actionNote   =   new   ActionNote ( colorizedAction ) ;  }
@ Test  void   canAnnotate ()   {  final   MarkupText   markupText   =  new   MarkupText ( ""abc123"" ) ;  assertNull ( actionNote . annotate ( buildRun ,  markupText ,  4 ) ) ;  final   String   output   =  markupText . toString ( false ) ;  assertTrue ( output . contains ( TAG_ACTION_BEGIN   +   ""\""""   +   UUID   +   ""\""""   +   TAG_ACTION_END ) ) ;  }
@ Override  public   Network   deserialize ( JsonParser   jsonparser ,  DeserializationContext   context )  throws  IOException   {  String   cidr   =  jsonparser . getText () ;  if  ( cidr   ==   null )   {  return  null ;  }  String []   parts   =  cidr . split ( ""/"" ,  2 ) ;  if  ( parts . length   !=   2 )   {  throw  new   RuntimeException ( ""Invalid cidr format: ""   +   cidr ) ;  }  int   prefixLength   =  Integer . parseInt ( parts [ 1 ] ) ;  try  {  return  new   Network ( InetAddress . getByName ( parts [ 0 ] ) ,  prefixLength ) ;  }   catch  ( UnknownHostException   e )   {  throw  new   RuntimeException ( e ) ;  }  }
@ Deprecated  public   Builder   connectTimeout ( int   val )   {  this . connectTimeout   =   Duration . ofMillis ( val ) ;  return  this ;  }
public   Builder   connectTimeout ( Duration   val )   {  this . connectTimeout   =   val ;  return  this ;  }
public   WebServiceClient . Builder   disableHttps ()   {  useHttps   =   false ;  return  this ;  }
public   Builder   host ( String   val )   {  this . host   =   val ;  return  this ;  }
public   WebServiceClient . Builder   port ( int   val )   {  port   =   val ;  return  this ;  }
public   Builder   locales ( List < String >   val )   {  this . locales   =   new   ArrayList <> ( val ) ;  return  this ;  }
@ Deprecated  public   Builder   readTimeout ( int   val )   {  this . requestTimeout   =   Duration . ofMillis ( val ) ;  return  this ;  }
public   Builder   requestTimeout ( Duration   val )   {  this . requestTimeout   =   val ;  return  this ;  }
@ Deprecated  public   Builder   proxy ( Proxy   val )   {  if  ( val   !=   null   &&   val   !=   Proxy . NO_PROXY )   {  this . proxy   =   ProxySelector . of ( ( InetSocketAddress )   val . address () ) ;  }  return  this ;  }
public   Builder   proxy ( ProxySelector   val )   {  this . proxy   =   val ;  return  this ;  }
public   WebServiceClient   build ()   {  return  new   WebServiceClient ( this ) ;  }
public   CountryResponse   country ()   throws  IOException ,  GeoIp2Exception   {  return  this . country ( null ) ;  }
@ Override  public   CountryResponse   country ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  this . responseFor ( ""country"" ,  ipAddress ,  CountryResponse . class ) ;  }
public   CityResponse   city ()   throws  IOException ,  GeoIp2Exception   {  return  this . city ( null ) ;  }
@ Override  public   CityResponse   city ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  this . responseFor ( ""city"" ,  ipAddress ,  CityResponse . class ) ;  }
public   InsightsResponse   insights ()   throws  IOException ,  GeoIp2Exception   {  return  this . insights ( null ) ;  }
public   InsightsResponse   insights ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  this . responseFor ( ""insights"" ,  ipAddress ,  InsightsResponse . class ) ;  }
private   < T >   T   responseFor ( String   path ,  InetAddress   ipAddress ,  Class < T >   cls )  throws  IOException ,  GeoIp2Exception   {  URI   uri   =  createUri ( path ,  ipAddress ) ;  HttpRequest   request   =  HttpRequest . newBuilder ()  . uri ( uri )  . timeout ( this . requestTimeout )  . header ( ""Accept"" ,  ""application/json"" )  . header ( ""Authorization"" ,  authHeader )  . header ( ""User-Agent"" ,  this . userAgent )  . GET ()  . build () ;  HttpResponse < InputStream >   response   =  null ;  try  {  response   =   this . httpClient  . send ( request ,  HttpResponse . BodyHandlers . ofInputStream () ) ;  return  handleResponse ( response ,  cls ) ;  }   catch  ( InterruptedException   e )   {  throw  new   GeoIp2Exception ( ""Interrupted sending request"" ,  e ) ;  }   finally  {  if  ( response   !=   null )   {  response . body () . close () ;  }  }  }
private   < T >   T   handleResponse ( HttpResponse < InputStream >   response ,  Class < T >   cls )  throws  GeoIp2Exception ,  IOException   {  int   status   =  response . statusCode () ;  URI   uri   =  response . uri () ;  if  ( status   >=   400   &&   status   <   500 )   {  this . handle4xxStatus ( response ) ;  }   else if  ( status   >=   500   &&   status   <   600 )   {  exhaustBody ( response ) ;  throw  new   HttpException ( ""Received a server error (""   +   status  +   "") for ""   +   uri ,  status ,  uri ) ;  }   else if  ( status   !=   200 )   {  exhaustBody ( response ) ;  throw  new   HttpException ( ""Received an unexpected HTTP status (""  +   status   +   "") for ""   +   uri ,  status ,  uri ) ;  }  InjectableValues   inject   =  new   JsonInjector ( locales ,  null ,  null ) ;  try  {  return  mapper . readerFor ( cls ) . with ( inject ) . readValue ( response . body () ) ;  }   catch  ( IOException   e )   {  throw  new   GeoIp2Exception ( ""Received a 200 response but could not decode it as JSON"" ,  e ) ;  }  }
private   void   handle4xxStatus ( HttpResponse < InputStream >   response )  throws  GeoIp2Exception ,  IOException   {  int   status   =  response . statusCode () ;  URI   uri   =  response . uri () ;  String   body ;  try  ( InputStream   bodyStream   =  response . body () )   {  body   =   new   String ( bodyStream . readAllBytes () ,  StandardCharsets . UTF_8 ) ;  if  ( body . equals ( """" ) )   {  throw  new   HttpException ( ""Received a ""   +   status   +   "" error for ""  +   uri   +   "" with no body"" ,  status ,  uri ) ;  }  }  try  {  Map < String ,  String >   content   =  mapper . readValue ( body , new   TypeReference < HashMap < String ,  String > > ()   {} ) ;  handleErrorWithJsonBody ( content ,  body ,  status ,  uri ) ;  }   catch  ( HttpException   e )   {  throw  e ;  }   catch  ( IOException   e )   {  throw  new   HttpException ( ""Received a ""   +   status   +   "" error for ""  +   uri   +   "" but it did not include the expected JSON body: ""  +   body ,  status ,  uri ) ;  }  }
private   static   void   handleErrorWithJsonBody ( Map < String ,  String >   content , String   body ,  int   status ,  URI   uri )  throws  GeoIp2Exception ,  HttpException   {  String   error   =  content . get ( ""error"" ) ;  String   code   =  content . get ( ""code"" ) ;  if  ( error   ==   null   ||   code   ==   null )   {  throw  new   HttpException ( ""Error response contains JSON but it does not specify code or error keys: ""  +   body ,  status ,  uri ) ;  }  switch  ( code )   {  case  ""IP_ADDRESS_NOT_FOUND"" :  case  ""IP_ADDRESS_RESERVED"" :  throw  new   AddressNotFoundException ( error ) ;  case  ""ACCOUNT_ID_REQUIRED"" :  case  ""ACCOUNT_ID_UNKNOWN"" :  case  ""AUTHORIZATION_INVALID"" :  case  ""LICENSE_KEY_REQUIRED"" :  case  ""USER_ID_REQUIRED"" :  case  ""USER_ID_UNKNOWN"" :  throw  new   AuthenticationException ( error ) ;  case  ""INSUFFICIENT_FUNDS"" :  case  ""OUT_OF_QUERIES"" :  throw  new   OutOfQueriesException ( error ) ;  case  ""PERMISSION_REQUIRED"" :  throw  new   PermissionRequiredException ( error ) ;  default:  
private   URI   createUri ( String   service ,  InetAddress   ipAddress )   throws  GeoIp2Exception   {  String   path   =  ""/geoip/v2.1/""   +   service   +   ""/""  +   ( ipAddress   ==   null  ?   ""me""   :  ipAddress . getHostAddress () ) ;  try  {  return  new   URI ( useHttps  ?   ""https""   :  ""http"" , null , host , port , path , null , null ) ;  }   catch  ( URISyntaxException   e )   {  throw  new   GeoIp2Exception ( ""Syntax error creating service URL"" ,  e ) ;  }  }
private   void   exhaustBody ( HttpResponse < InputStream >   response )   throws  HttpException   {  try  ( InputStream   body   =  response . body () )   {  
@ Deprecated  @ Override  public   void   close ()   throws  IOException   {  }
@ Override  public   String   toString ()   {  return  ""WebServiceClient{""  +   ""host='""   +   host   +   '\''  +   "", locales=""   +   locales  +   "", useHttps=""   +   useHttps  +   "", port=""   +   port  +   "", requestTimeout=""   +   requestTimeout  +   "", userAgent='""   +   userAgent   +   '\''  +   "", mapper=""   +   mapper  +   "", httpClient=""   +   httpClient  +   '}' ;  }
public   Builder   locales ( List < String >   val )   {  this . locales   =   val ;  return  this ;  }
public   Builder   withCache ( NodeCache   cache )   {  this . cache   =   cache ;  return  this ;  }
public   Builder   fileMode ( FileMode   val )   {  if  ( this . stream   !=   null   &&   FileMode . MEMORY   !=   val )   {  throw  new   IllegalArgumentException ( ""Only FileMode.MEMORY is supported when using an InputStream."" ) ;  }  this . mode   =   val ;  return  this ;  }
public   DatabaseReader   build ()   throws  IOException   {  return  new   DatabaseReader ( this ) ;  }
private   < T >   LookupResult < T >   get ( InetAddress   ipAddress ,  Class < T >   cls , DatabaseType   expectedType )  throws  IOException   {  if  ( ( databaseType   &   expectedType . type )   ==   0 )   {  String   caller   =  Thread . currentThread () . getStackTrace () [ 3 ]  . getMethodName () ;  throw  new   UnsupportedOperationException ( ""Invalid attempt to open a ""   +   getMetadata () . getDatabaseType ()  +   "" database using the ""   +   caller   +   "" method"" ) ;  }  DatabaseRecord < T >   record   =  reader . getRecord ( ipAddress ,  cls ) ;  T   o   =  record . getData () ;  return  new   LookupResult <> ( o ,  ipAddress . getHostAddress () ,  record . getNetwork () ) ;  }
@ Override  public   void   close ()   throws  IOException   {  this . reader . close () ;  }
@ Override  public   CountryResponse   country ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < CountryResponse >   r   =  getCountry ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < CountryResponse >   tryCountry ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getCountry ( ipAddress ) ;  }
private   Optional < CountryResponse >   getCountry ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < CountryResponse >   result   =  this . get ( ipAddress , CountryResponse . class , DatabaseType . COUNTRY ) ;  CountryResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   CountryResponse ( response , result . getIpAddress () , result . getNetwork () , locales ) ) ;  }
@ Override  public   CityResponse   city ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < CityResponse >   r   =  getCity ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < CityResponse >   tryCity ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getCity ( ipAddress ) ;  }
private   Optional < CityResponse >   getCity ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < CityResponse >   result   =  this . get ( ipAddress , CityResponse . class , DatabaseType . CITY ) ;  CityResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   CityResponse ( response , result . getIpAddress () , result . getNetwork () , locales ) ) ;  }
@ Override  public   AnonymousIpResponse   anonymousIp ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < AnonymousIpResponse >   r   =  getAnonymousIp ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < AnonymousIpResponse >   tryAnonymousIp ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getAnonymousIp ( ipAddress ) ;  }
private   Optional < AnonymousIpResponse >   getAnonymousIp ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < AnonymousIpResponse >   result   =  this . get ( ipAddress , AnonymousIpResponse . class , DatabaseType . ANONYMOUS_IP ) ;  AnonymousIpResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   AnonymousIpResponse ( response , result . getIpAddress () , result . getNetwork () ) ) ;  }
@ Deprecated  @ Override  public   IpRiskResponse   ipRisk ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < IpRiskResponse >   r   =  getIpRisk ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Deprecated  @ Override  public   Optional < IpRiskResponse >   tryIpRisk ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getIpRisk ( ipAddress ) ;  }
@ Deprecated  private   Optional < IpRiskResponse >   getIpRisk ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  LookupResult < IpRiskResponse >   result   =  this . get ( ipAddress , IpRiskResponse . class , DatabaseType . IP_RISK ) ;  IpRiskResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   IpRiskResponse ( response , result . getIpAddress () , result . getNetwork () ) ) ;  }
@ Override  public   AsnResponse   asn ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < AsnResponse >   r   =  getAsn ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < AsnResponse >   tryAsn ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getAsn ( ipAddress ) ;  }
private   Optional < AsnResponse >   getAsn ( InetAddress   ipAddress )  throws  IOException ,  GeoIp2Exception   {  LookupResult < AsnResponse >   result   =  this . get ( ipAddress , AsnResponse . class , DatabaseType . ASN ) ;  AsnResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   AsnResponse ( response , result . getIpAddress () , result . getNetwork () ) ) ;  }
@ Override  public   ConnectionTypeResponse   connectionType ( InetAddress   ipAddress )  throws  IOException ,  GeoIp2Exception   {  Optional < ConnectionTypeResponse >   r   =  getConnectionType ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < ConnectionTypeResponse >   tryConnectionType ( InetAddress   ipAddress )  throws  IOException ,  GeoIp2Exception   {  return  getConnectionType ( ipAddress ) ;  }
private   Optional < ConnectionTypeResponse >   getConnectionType ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < ConnectionTypeResponse >   result   =  this . get ( ipAddress , ConnectionTypeResponse . class , DatabaseType . CONNECTION_TYPE ) ;  ConnectionTypeResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   ConnectionTypeResponse ( response , result . getIpAddress () , result . getNetwork () ) ) ;  }
@ Override  public   DomainResponse   domain ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < DomainResponse >   r   =  getDomain ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < DomainResponse >   tryDomain ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getDomain ( ipAddress ) ;  }
private   Optional < DomainResponse >   getDomain ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < DomainResponse >   result   =  this . get ( ipAddress , DomainResponse . class , DatabaseType . DOMAIN ) ;  DomainResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   DomainResponse ( response , result . getIpAddress () , result . getNetwork () ) ) ;  }
@ Override  public   EnterpriseResponse   enterprise ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < EnterpriseResponse >   r   =  getEnterprise ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < EnterpriseResponse >   tryEnterprise ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getEnterprise ( ipAddress ) ;  }
private   Optional < EnterpriseResponse >   getEnterprise ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < EnterpriseResponse >   result   =  this . get ( ipAddress , EnterpriseResponse . class , DatabaseType . ENTERPRISE ) ;  EnterpriseResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   EnterpriseResponse ( response , result . getIpAddress () , result . getNetwork () , locales ) ) ;  }
@ Override  public   IspResponse   isp ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  Optional < IspResponse >   r   =  getIsp ( ipAddress ) ;  if  ( r . isEmpty () )   {  throw  new   AddressNotFoundException ( ""The address ""  +   ipAddress . getHostAddress ()   +   "" is not in the database."" ) ;  }  return  r . get () ;  }
@ Override  public   Optional < IspResponse >   tryIsp ( InetAddress   ipAddress )   throws  IOException , GeoIp2Exception   {  return  getIsp ( ipAddress ) ;  }
private   Optional < IspResponse >   getIsp ( InetAddress   ipAddress )   throws  IOException ,  GeoIp2Exception   {  LookupResult < IspResponse >   result   =  this . get ( ipAddress , IspResponse . class , DatabaseType . ISP ) ;  IspResponse   response   =  result . getModel () ;  if  ( response   ==   null )   {  return  Optional . empty () ;  }  return  Optional . of ( new   IspResponse ( response , result . getIpAddress () , result . getNetwork () ) ) ;  }
public   Metadata   getMetadata ()   {  return  this . reader . getMetadata () ;  }
@ Override  public   Object   findInjectableValue ( Object   valueId ,  DeserializationContext   ctxt , BeanProperty   forProperty ,  Object   beanInstance )   {  if  ( ""locales"" . equals ( valueId ) )   {  return  locales ;  }  if  ( ""ip_address"" . equals ( valueId ) )   {  return  ip ;  }  if  ( ""network"" . equals ( valueId ) )   {  return  network ;  }  if  ( ""traits"" . equals ( valueId ) )   {  return  new   Traits ( ip ,  network ) ;  }  return  null ;  }
@ JsonProperty ( ""ip_address"" )  public   String   getIpAddress ()   {  return  this . ipAddress ;  }
@ JsonProperty  @ JsonSerialize ( using   =   ToStringSerializer . class )  public   Network   getNetwork ()   {  return  this . network ;  }
@ JsonProperty ( ""is_anonymous"" )  public   boolean   isAnonymous ()   {  return  isAnonymous ;  }
@ JsonProperty ( ""is_anonymous_vpn"" )  public   boolean   isAnonymousVpn ()   {  return  isAnonymousVpn ;  }
@ JsonProperty ( ""is_hosting_provider"" )  public   boolean   isHostingProvider ()   {  return  isHostingProvider ;  }
@ JsonProperty ( ""is_public_proxy"" )  public   boolean   isPublicProxy ()   {  return  isPublicProxy ;  }
@ JsonProperty ( ""is_residential_proxy"" )  public   boolean   isResidentialProxy ()   {  return  isResidentialProxy ;  }
@ JsonProperty ( ""is_tor_exit_node"" )  public   boolean   isTorExitNode ()   {  return  isTorExitNode ;  }
@ JsonProperty ( ""ip_risk"" )  public   double   getIpRisk ()   {  return  this . ipRisk ;  }
@ JsonValue  @ Override  public   String   toString ()   {  return  this . name ;  }
@ JsonCreator  public   static   ConnectionType   fromString ( String   s )   {  if  ( s   ==   null )   {  return  null ;  }  switch  ( s )   {  case  ""Dialup"" :  return  ConnectionType . DIALUP ;  case  ""Cable/DSL"" :  return  ConnectionType . CABLE_DSL ;  case  ""Corporate"" :  return  ConnectionType . CORPORATE ;  case  ""Cellular"" :  return  ConnectionType . CELLULAR ;  case  ""Satellite"" :  return  ConnectionType . SATELLITE ;  default:  return  null ;  }  }
@ JsonProperty ( ""connection_type"" )  public   ConnectionType   getConnectionType ()   {  return  this . connectionType ;  }
@ JsonProperty ( ""maxmind"" )  public   MaxMind   getMaxMind ()   {  return  this . maxmind ;  }
@ JsonProperty ( ""registered_country"" )  public   Country   getRegisteredCountry ()   {  return  this . registeredCountry ;  }
@ JsonProperty ( ""represented_country"" )  public   RepresentedCountry   getRepresentedCountry ()   {  return  this . representedCountry ;  }
